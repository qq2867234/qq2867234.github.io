
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Java常用容器的实现原理 | Shadow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Shadow">
    

    
    <meta name="description" content="本文对Java常用容器类的源码进行了分析，加深对容器类底层实现原理的理解，从而能够在不同场景中选择合适的容器类。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常用容器的实现原理">
<meta property="og:url" content="http://qq2867234.github.io/2016/03/05/The-underlying-implementation-of-common-container/index.html">
<meta property="og:site_name" content="Shadow">
<meta property="og:description" content="本文对Java常用容器类的源码进行了分析，加深对容器类底层实现原理的理解，从而能够在不同场景中选择合适的容器类。">
<meta property="og:image" content="http://7xtdiw.com1.z0.glb.clouddn.com/Java-Container.png">
<meta property="og:updated_time" content="2016-05-12T05:42:10.076Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java常用容器的实现原理">
<meta name="twitter:description" content="本文对Java常用容器类的源码进行了分析，加深对容器类底层实现原理的理解，从而能够在不同场景中选择合适的容器类。">

    
    <link rel="alternative" href="/atom.xml" title="Shadow" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Shadow" title="Shadow"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Shadow">Shadow</a></h1>
				<h2 class="blog-motto">Every day a little better than yesterday</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qq2867234.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/05/The-underlying-implementation-of-common-container/" title="Java常用容器的实现原理" itemprop="url">Java常用容器的实现原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Shadow" target="_blank" itemprop="author">Shadow</a>
		
  <p class="article-time">
    <time datetime="2016-03-04T16:24:27.000Z" itemprop="datePublished"> 发表于 2016-03-05</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h2 id="容器概念">容器概念</h2><p>容器就是我们常说的集合，那为什么要有一个新的名称呢？因为，Java的类库中使用了Collection来指代该类库的一个特殊子集，而Collection的中文又有集合的意思，所以为了避免混淆，使用了范围更广的术语“容器”来称呼。</p>
<p>Java容器类的用途是“保存对象”，包含两大类别：</p>
<ol>
<li><strong>Collection</strong>：保存一个独立元素的序列。</li>
<li><strong>Map</strong>：保存一组成对的“键值对”。</li>
</ol>
<p>但是我们一般会说有4种容器：<strong>List、Set、Queue和Map</strong>。它们各有2-3个实现版本。</p>
<p>下面是容器类库的关系图（没有包括与同步相关的实现类）：<br><img src="http://7xtdiw.com1.z0.glb.clouddn.com/Java-Container.png" alt="Java容器类库关系图"></p>
<ul>
<li>常用容器用黑色粗线框表示。</li>
<li>点线框表示接口。</li>
<li>虚线框表示抽象类，大部分以Abstract开头，只是部分实现了特定接口的工具。</li>
<li>实线框表示普通类。</li>
<li>带有空心箭头的点线表示一个类实现了一个接口。</li>
<li>带有实心箭头的点线表示某个类可以生成箭头所指向类的对象。</li>
<li>实线表示一个类继承了另一个类。</li>
</ul>
<p>上面错综复杂的类图，可以简单的总结为：</p>
<ul>
<li>两个顶级接口：Collection和Map。而List、Set和Queue3个接口继承了Collection接口。</li>
<li>Map与Collection没有关联，只不过Map内部提供方法可以生成Collection集合。</li>
<li>Collection和Map都能生成一个迭代器Iterator，从而统一了容器的遍历方式。</li>
<li>List接口常用的实现类：ArrayList和LinkedList。</li>
<li>Map接口常用的实现类：HashMap、TreeMap和LinkedHashMap。</li>
<li>Set接口常用的实现类：HashSet、TreeSet和LinkedHashSet。</li>
<li>最后是容器操作的两大工具类：Collections和Arrays，提供了大量的静态方法来操作容器。</li>
</ul>
<p>下面分别介绍List、Map和Set的各个常用实现类：</p>
<h2 id="List">List</h2><p>按元素的插入顺序来保存元素，允许元素重复，也允许null值。</p>
<h3 id="ArrayList">ArrayList</h3><p><strong>底层实现</strong>：数组<br><strong>内部顺序</strong>：下标顺序<br><strong>优点</strong>：按数组下标访问、在数组末尾添加元素时性能高<br><strong>缺点</strong>：按下标插入、删除元素时性能低，因为要移动受影响的元素<br><strong>关键点</strong>：自动扩容。由于数组长度有限，当长度不够时能自动扩容，每次增加50%容量，用System.arraycopy()复制元素到新数组，因此可以的话最好指定数组的初始容量。</p>
<p>基于数组实现。适合随机访问元素，但是插入和删除元素比较慢。</p>
<p>ArrayList的底层使用对象数组elementData来保存元素：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底层使用对象数组来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 实际保存的元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 数组默认的初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; </span><br><span class="line"><span class="comment">// 保存数组被修改的次数（add remove等操作都会增加这个值），用在迭代遍历时防止数组被修改</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>ArrayList提供了3种构造函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化为空数组，在第一次add的时候，才会构造一个默认初始容量为10的数组</span></span><br><span class="line"><span class="comment">// 在老的jdk版本中，创建的时候就初始化了一个容量为10的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定初始化容量来创建ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按指定的容量initialCapacity来初始化数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于已有的集合创建ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将集合转换成对象数组，并将引用赋给elementData </span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 将元素个数保存到size</span></span><br><span class="line">    size = elementData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加元素：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向数组尾部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保数组的容量足够容纳新的元素，如果容纳不下，将进行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将元素保存到数组中</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向数组中的指定位置添加元素</span></span><br><span class="line"><span class="comment">// 如果当前位置有元素，则当前位置以及之后的所有元素，都向后移动一位，以腾出空位容纳新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 如果数组容纳不下新元素，将进行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将当前位置以及之后的所有元素，都向后移动一位（开销较大）</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 将元素保存到数组中</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ArrayList封装了ensureCapacityInternal()方法来确保数组的容量足够容纳新的元素，如果不足以容纳新的元素，将进行扩容：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数组是空的</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 这时候minCapacity其实就是1，所以下面的minCapacity会等于默认的初始容量DEFAULT_CAPACITY</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要的最小容量 大于 目前数组的容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 数组扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组进行扩容时，每次数组容量的增长大约是其原容量的1.5倍，同时会将老数组中的元素重新拷贝一份到新的数组中。这种操作的代价很高，因此在使用时，如果我们可预知要保存多少元素，最好在构造ArrayList实例时指定其容量，以免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。<br>下面是数组扩容方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新的容量 = 原数组的容量 + 原数组的容量/2 </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用Arrays工具类的copyOf方法，用新的容量创建新的数组，并复制旧的数组元素</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取元素，直接通过下标访问，速度很快：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 直接根据下标访问数组，所以速度很快</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移除元素，涉及到移动元素，所以开销相对较大：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标是否越界，越界则抛出异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 取出旧的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 计算要移动的元素个数    </span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将被删除元素之后的所有元素，向前移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 将最后一位元素置为null，好让垃圾回收器清理没用的元素</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回被移除元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="fail-fast">fail-fast</h4><p>最后介绍一下fail-fast机制（快速失败机制），几乎所有的容器类在迭代遍历的时候，都采用了这种机制，这里以ArrayList为例进行介绍，后面将不再赘述。</p>
<p>我们知道ArrayList不是线程安全的，因此如果在使用迭代器的过程中有其它线程修改了ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast。</p>
<p>fail-fast机制在源码中的实现是通过modCount变量来完成，modCount记录了对ArrayList的修改次数，任何对ArrayList内容的修改都将增加这个值，在迭代器初始化过程中会将这个值保存在迭代器的expectedModCount变量中。<br>在迭代过程中，始终判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了ArrayList，立即抛出异常，终止迭代：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedList">LinkedList</h3><p><strong>底层实现</strong>：双向链表<br><strong>顺序</strong>：节点串连顺序<br><strong>优点</strong>：插入、删除元素时只要修改链表引用，不需要移动元素，虽然还需要遍历部分链表，但是相对ArrayList的移动元素来说，这部分开销可以忽略。<br><strong>缺点</strong>：按下标访问时需要遍历链表到指定的位置（时间复杂度O(n/2)）。占用更多空间。</p>
<p>基于双向链表实现，在插入和删除元素时比ArrayList更加高效，但是随机访问相对较慢。<br>另外，LinkedList还添加了可以用作栈、队列或双端队列的方法。</p>
<p>既然是基于链表，那就少不了节点，LinkedList中的节点类被定义为静态内部私有类Node：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存元素值</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; next;  </span><br><span class="line">    <span class="comment">// 指向上一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;  </span><br><span class="line">    </span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于双向链表的实现，保存了首、尾节点的引用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指向首节点的引用</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 指向尾节点的引用</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// 节点个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>添加元素到链表尾部：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先临时保存旧的尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建新节点，将旧的尾节点 作为 新节点的前一个节点(有点绕)</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 然后将新节点作为尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果之前没有尾节点，说明是第一个元素，让新节点同时作为首节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="comment">// 否则，将新节点作为旧的尾节点的下一个节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取元素，需要从头(或从尾)遍历链表，速度没有ArrayList快：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据下标获取链表中的元素值</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据index判断是在前半区间还是后半区间，从而选择头开始遍历还是从尾开始遍历，将时间复杂度由O(n)变为O(n/2)</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标小于容量的一半，从链首开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 跳过index个节点（随机访问的主要时间开销都在这）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="comment">// 返回指定的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，从链尾开始遍历</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">// 跳过index个节点（随机访问的主要时间开销都在这）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="comment">// 返回指定的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移除元素：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据下标获取节点</span></span><br><span class="line">    Node&lt;E&gt; node = node(index);</span><br><span class="line">    <span class="comment">// 移除指定的节点</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除指定节点，链表移除一个节点的时间复杂度为O(1)</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存要移除节点的元素值和前后节点引用</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="comment">// 如果前一个节点的引用为null，说明移除的是首节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 让下一个节点成为新的首节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则 </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将要移除元素的后一个节点，作为上一个节点的下一个节点(有点绕，慢慢理解)</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 然后再清除要移除元素的前一个节点引用</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除的是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 让上一个节点成为新的尾节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则 </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将要移除元素的前一个节点，作为下一个节点的上一个节点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要移除节点的元素值置为null</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Map">Map</h2><h3 id="HashMap">HashMap</h3><p><strong>底层实现</strong>：散列表，用链表解决碰撞问题（数组+散列函数+链表）。<br><strong>顺序</strong>：无序且不稳定，每次resize都会改变原有顺序。<br><strong>关键点</strong>：碰撞解决和resize。Jdk 7使用链表解决碰撞，在Jdk 8中，如果一个bucket中碰撞的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。添加键值对的时候，如果超过了负载因子所限制的容量，则会重新创建一个原来长度两倍的HashMap，并使用优化算法重新计算元素在bucket中的下标。<br><strong>注意点</strong>：如果要使用自定义的类来作为HashMap的键，必须同时重载hashCode()和equals()方法，否则将使用Object的hashCode()和equals()，这两个方法都是基于对象的地址来处理，直接导致无法正确处理你的键。<br><strong>优化</strong>：可以通过创建自己的Map来进一步提高查询速度，并且令新的Map只针对你使用的特定类型，这样可以避免与Object之间的类型转换操作。要达到更高的性能，可以参考Donald Knuth的The Art Of Computer Programming, Volume 3: Sorting and Searching, Second Edition。使用数组代替溢出桶，这有两个好处：1. 可以针对磁盘存储方式做优化； 2. 在创建和回收单独的记录时，能节约很多时间。</p>
<p>基于Map接口实现、允许null键/值、非同步、不保证有序、也不保证序不随时间变化。</p>
<p>HashMap的底层就是一个数组，数组中的每个元素都是一个链表，它保存了链表的首节点引用，链表的每个节点为键值对Entry<k,v>：<br>PS：很多人说，当没发生键碰撞时，数组中保存的是键值对，只有当键碰撞时，才会使用链表。其实底层的实现，并没有这个判断过程，无论键是否发送碰撞，都是用链表来保存键值对，只不过当没有发生键碰撞时，链表中只有一个节点。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底层用数组保存键值对</span></span><br><span class="line"><span class="comment">// 更准确的说法应该是：用数组保存链表的首节点，因为对于链表，只要有了首节点，就可以遍历整个链表，所以在这里只要将首节点引用保存在数组中即可</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认的初始容量16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 等于16</span></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 实际的负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 可负载容量：就是下一次要进行resize的容量（table.length*loadFactor）</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure></k,v></p>
<p>下面看看用来保存键值对的Entry<k,v>类，每个Entry<k,v>对象，才真正的保存了键值对数据，同时还持有指向下一个键值对的引用，这就构成了链表，用来解决键的碰撞问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 保存值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 键碰撞发生时，指向下一个键值对，如果没有冲突则next为null。</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></k,v></k,v></p>
<p>HashMap提供了4种构造函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认的初始容量16和默认的负载因子0.75来创建HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用指定的初始容量和默认的负载因子0.75来创建HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用指定的初始容量和指定的负载因子来创建HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果容量超过最大容量，则使用最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">// 作为子类的初始化钩子函数</span></span><br><span class="line">    <span class="comment">// 这个方法在HashMap中为空方法。在HashMap的子类(比如LinkedHashMap)中会覆盖该方法，从而执行子类需要的相关代码。</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用已有的Map来创建新的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据参数中map的键值对个数来计算需要的容量，并使用默认的负载因子，来创建HashMap</span></span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">// 使用指定容量初始化table(Entry数组)</span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    <span class="comment">// 将参数中map中的键值对放入新创建的table中</span></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到一个[&gt;=number]的[2的倍数值]（8-&gt;16; 15-&gt;16; 16-&gt;16; 17-&gt;32）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到一个&gt;=toSize的2的倍数值，作为新的数组容量</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 可负载容量（总容量*负载因子，一旦达到可负载容量，就需要resize）</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用指定容量初始化Entry数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>向HashMap中添加一个键值对的过程大致如下：</p>
<ol>
<li>首先计算key的hash值</li>
<li>根据hash值和数组长度，计算得到该key在数组中的存储位置（即数组下标）。</li>
<li>创建新的键值对对象，并将其插入数组下标所指向的链表的头部。</li>
<li>更新数组下标所指向的引用，将其指向新的链表头部。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// table还未初始化，则将其初始化为默认的容量大小16</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 允许null键，当key为null时，将其放在数组的第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值和数组长度，计算key在数组中的存储位置（即数组下标）</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 如果数组下标i处的Entry不为null，则遍历该链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 如果在链表中找到重复的键值对，则将其替换为新的值，并返回旧的值</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 将键值对保存到数组的下标i中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="comment">// 如果是字符串，用特殊的hash函数来计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash算法    </span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据hash值和数组的长度，计算指定hash在数组中的存储位置（即数组下标）</span></span><br><span class="line"><span class="comment">// 计算该键值对应该保存在数组的哪个下标处</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法非常巧妙，它利用了HashMap底层数组的长度总是2的整数次方，从而可以用掩码来代替取模运算，消除取模运算带来的开销，提升效率。（这也是为什么每次扩容数组的时长度都是2的整数次方的原因）</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据hash值和数组下标，保存键值对到相应位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果键值对个数已达到可负载容量</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 将table数组的长度扩容到原来的2倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 再重新计算新的hash值和数组下标</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建键值对并保存到相应位置</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建键值对并将其保存到table数组的相应位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先根据数组下标取出原的链表首节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 再创建新的键值对，并将其内部的next引用指向原来的链表首节点，让其成为新的首节点，最后将新的首节点保存到table数组的指定下标中。</span></span><br><span class="line">    <span class="comment">// （将新的键值对插入链表的头部，作为链表首节点，并更新数组中原来的链表首节点）</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>关于上面的实现，有一点需要介绍一下：<br>之前，为了使散列分布均匀，数组的长度通常使用质数，因为这样能够减少键碰撞的概率。但是，后来事实证明，质数实际上并不是理想的数组长度，经过广泛的测试之后，Java的散列函数都改为使用2的整数次方，因为，对于现代的处理器来说，<strong>除法和求余数是最慢的操作，使用2的整数次方长度的数组，可用掩码来代替除法</strong>。<br>因为get()是使用最多的操作，求余数的%操作是其开销最大的部分，而使用2的整数次方可以消除此开销。<br>（参考Java编程思想第4版 494页）</p>
</blockquote>
<p>从HashMap中取出一个键值对的过程：</p>
<ol>
<li>先计算key的hash值</li>
<li>再根据hash值计算出该key在数组中的下标</li>
<li>最后取出该下标处的Entry，并返回对应的value<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值和数组长度，计算得到数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 遍历数组下标所指向的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 使用key.equals()在链表中找到符合的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            <span class="keyword">return</span> e.getValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>HashMap 的 resize</strong>（rehash）：<br>随着HashMap中键值对数量的增多，键的碰撞概率也随之增高，为了保证HashMap的查询效率，当键值对个数超过可负载容量时，就需要将数组的大小扩展为原来的2倍，然后重新计算每个元素在数组中的位置，这就是HashMap的resize。<br>这是一个非常消耗性能的操作，所以如果我们可以预先知道HashMap中键值对的个数，那么预设初始容量能够有效的提高HashMap的性能。<br>下面看看resize的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用新的容量来扩展数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原来的数组容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    <span class="comment">// 如果原来已经达到了最大容量，则不再对数组进行扩容，而是将可负载的容量改为最大容量（相当于将负载因子从0.75置为1）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用新的容量初始化数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来的键值对保存到新的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原来的键值对保存到新的数组中</span></span><br><span class="line"><span class="comment">// 所有原来的键值对对象都可以接着使用，不用重新创建新的键值对，需要改变的只它们之间的引用关系。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历原来的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">// 遍历所指向的链表中的每个Entry</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">// 先保存下一个Entry，以便下一次循环中使用</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 如果需要重新计算hash值</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                <span class="comment">// 重新计算hash值</span></span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新计算新的数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// newTable[i]保存的是新数组中对应下标所指向的链表首节点引用</span></span><br><span class="line">            <span class="comment">// 这里将e.next指向原来的首节点引用，这样e就成为了链表新的首节点</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">// 将链表新的首节点引用e保存到新数组的指定下标ｉ中</span></span><br><span class="line">            <span class="comment">// 这上下两行代码，完美的使用链表来解决了碰撞问题（无论碰撞与否都用同样的方式来处理）</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">// 将e指向下一个Entry，在下一轮循环中对其进行同样的处理</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么每次数组都是扩展为原来的2倍？<br>为了保证数组的容量始终为2的n次方，有了这个前提，就可以把根据hash值来计算数组下标的取模运算，转换为掩码运算，从而提高效率。<br>（因为在HashMap中，需要根据hash值来计算数组的下标，hash值通常都大于数组的长度，一般的做法是采用取模运算，而取模是很慢的操作，所以为了优化这个操作，使用2的n次方长度的数组，可用掩码来代替取模运算。 因为get()是使用最多的操作，其中取模操作是其开销最大的部分，而使用2的整数次方可以消除此开销。 ）</p>
<h3 id="LinkedHashMap">LinkedHashMap</h3><p><strong>底层实现</strong>：散列表+双向循环链表<br><strong>顺序</strong>：元素无序存放，但遍历时可以按照插入顺序或者最近访问顺序来遍历。<br><strong>优点</strong>：在迭代访问时更快，可按插入顺序或访问顺序来遍历。<br><strong>缺点</strong>：需要额外维护双向循环链表来保存元素的迭代顺序。</p>
<p>在HashMap的基础上，在内部使用双向循环链表维护元素的迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。这样可以使速度接近HashMap，同时又保持了迭代顺序。<br>保存的元素本身是无序的，但是在遍历的时候，可以元素的插入顺序或者是最近最少使用的顺序来遍历。<br>只比HashMap慢一点，而在迭代访问时反而更快，因为它使用双向循环链表维护内部顺序。</p>
<p>LinkedHashMap继承自HashMap，通过重写父类相关方法，来实现自己的特性。</p>
<p>添加了两个属性header和accessOrder：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存用来维护迭代顺序的双向循环链表的首节点，首节点不保存数据，内部的after指向第一个元素，before则指向最后一个元素。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"><span class="comment">// 是否按照元素的访问顺序来排序，默认为false，按照插入顺序排序</span></span><br><span class="line"><span class="comment">// 如果为true，那么首先按照插入顺序排序，当某个元素被访问或修改时，会将其移到链表尾部，下次淘汰元素的时候从链首开始淘汰，这就是最近久未使用淘汰算法（LRU）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></p>
<p>重新定义了Entry<k, v="">类，继承自HashMap.Entry<k,v>，并添加了前后节点的引用，来实现双向循环链表：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存前后节点的引用</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></k,v></k,></p>
<p>添加一个键值对：<br>LinkedHashMap直接使用HashMap的put方法来添加一个键值对，但是重写了HashMap的addEntry和createEntry方法，来提供特有的双向循环链表实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先调用了父类的addEntry方法，在方法中判断是否要进行resize，再调用createEntry</span></span><br><span class="line">    <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line">    <span class="comment">// 如果需要的话，删除最近最少使用的键值对  </span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="comment">// 在LinkedHashMap中，removeEldestEntry()方法永远返回false，因为它默认不移除旧的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建键值对并将其保存到table数组的相应位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先根据数组下标取出原来的链表首节点</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 创建新的键值对e，并将e.next引用指向原来的首节点，让e成为新的首节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    <span class="comment">// 将e作为新的首节点，保存到table数组的指定下标中</span></span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 这是与HashMap中createEntry方法唯一不同的地方</span></span><br><span class="line">    <span class="comment">// 在首节点之前插入一个节点，因为是双向循环链表，就相当于插于在链尾插入一个节点</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在指定节点前插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认返回false，不移除任何键值对</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取一个键值对：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key获取键值对</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果启用了访问排序，则记录访问顺序；否则不做任何操作</span></span><br><span class="line">    e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 根据key获取对应键值对</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果启用了访问排序，则记录访问顺序，将最新访问的元素移到链表尾部（链表是按访问顺序排序，最近访问的元素放末尾）</span></span><br><span class="line"><span class="comment">// 否则不做任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    <span class="comment">// 如果定义了LinkedHashMap的迭代顺序为访问顺序</span></span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        <span class="comment">// 将当前节点移到链表尾部</span></span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于LinkedHashMap构建LRU缓存（最近最少使用算法）：</p>
<p>前面已经介绍过，在创建LInkedHashMap的时候将accessOrder置为true，此时元素的迭代顺序就是其访问顺，另外LinkedHashMap还提供了removeEldestEntry(Map.Entry<k,v> eldest)方法，在插入新的元素后，put将调用此方法，根据此方法的返回值来决定是否删除最久未使用的元素，默认返回false，即永远不删除旧的元素。</k,v></p>
<p>所以，基于LInkedHashMap来构建LRU缓存将非常方便，只需要继承LInkedHashMap，并重写removeEldestEntry方法，在方法中定义淘汰规则即可，比如希望只保存100个最近使用的元素，超过100个后，每次添加新的元素将删除最旧的元素，则实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="title">private</span> <span class="title">static</span> <span class="title">final</span> <span class="title">int</span> <span class="title">MAX_ENTRIES</span> </span>= <span class="number">100</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TreeMap">TreeMap</h3><p><strong>底层实现</strong>：红黑树（一种自平衡二叉树，可在O(log n)时间内做查找、插入和删除，n是树中元素的数目）<br><strong>排序</strong>：按照元素的排序顺序来保存元素（顺序由Comparable或Comparator决定）。<br><strong>优点</strong>：元素是有序的，同时具有不错的查询速度（O(log n)）。<br><strong>缺点</strong>：速度不如HashMap快。<br><strong>注意点</strong>：元素必须实现Comparable接口，或者在创建TreeMap的时候传入Comparator参数来指导排序，否则在程序运行时将抛出异常。（Java提供了一个Comparable接口，该接口定义了一个compareTo(Object obj)方法，实现了该接口的对象就可以比较大小）</p>
<p>在TreeMap中保存了一个root节点，是红黑树的根节点：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>TreeMap提供了与其它Map不同的Entry<k,v>实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树的节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    K key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 节点的颜色</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></k,v></p>
<p>TreeMap提供了如下几个构造函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供自定义的comparator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加一个键值对，按照顺序插入红黑树的相应位置：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 如果根节点为null，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 好像没什么用</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">// 创建新的节点，作为根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较结果</span></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    <span class="comment">// 保存父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 区分是使用 comparator 还是 comparable</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 如果定义了comparator（在创建TreeMap的时候作为参数传入），则使用comparator来进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历红黑色，找到合适的位置插入新节点</span></span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="comment">// 保存当前节点为父节点</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 比较插入的新key与当前所比较节点的key</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">// 新key小于当前节点key，进入左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 新key大于当前节点key，进入左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="comment">// key值相等，则使用新的value替换旧的value，结束。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则使用Comparable来进行比较（此时要求作为Key的类必须实现Comparable接口并重写compareTo方法，否则将抛出异常）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 遍历红黑色，找到合适的位置</span></span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="comment">// 保存当前节点，在循环结束后用来作为新节点的父节点</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 比较插入的新key与当前所比较节点的key</span></span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="comment">// 新key小于当前节点key，进入左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 新key大于当前节点key，进入左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="comment">// key值相等，则使用新的value替换旧的value，结束。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明已找到新节点的插入位置</span></span><br><span class="line">    <span class="comment">// 创建一个新的节点，并将前面找到的节点作为新节点的父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="comment">// 新key值小于父节点key值，作为左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="comment">// 新key值大于父节点key值，作为右子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 红黑树的平衡调整（这才是红黑树最关键，也是最复杂的地方，在这里就不介绍了，因为我也不懂...）</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取一个键值对，在红黑树中从根节点开始往下查找，直到找到对应值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    <span class="comment">// 如果定义了Comparator，则使用Comparator进行比较，过程与接下来的代码基本一致</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将key向上转型为Comparable接口</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从根节点开始向下遍历子节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较要查找的key与当前节点的key</span></span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="comment">// 如果要查找的key小于当前节点的key，则进入左子树</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="comment">// 如果要查找的key大于当前节点的key，则进入右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="comment">// 找到key，返回节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Set">Set</h2><p>不保存重复的元素，元素的排序方式在不同实现类之间有所不同。<br>因为要保证元素是唯一的，所以插入Set的元素必须定义equals()方法来确保对象的唯一性，否则将使用Object的equals()方法，而它比较的是对象的地址。</p>
<h3 id="HashSet">HashSet</h3><p>基于HashMap实现。为快速查找而设计。<br>保存的元素是无序的（根据元素的hashCode值来决定元素的存储位置，所以可以认为是无序）。<br>如果元素是自定义的类，必须定义hashCode()方法，否则将使用Object的hashCode()，而它默认使用对象的地址来计算散列值，这明显不是我们想要的结果。</p>
<p>HashSet的底层实现非常的简单，使用HashMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用HashMap的key保存HashSet中所有元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// 定义一个虚拟的Object对象作为HashMap的value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>创建一个HashSet的时候，就是在内部实例化了一个HashMap，构造函数如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，底层会初始化一个HashMap </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以指定的初始容量创建HashSet ，其实就是以相应的参数创建HashMap </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以指定的初始容量和负载因子创建HashSet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，HashSet还有个特殊的构造函数，为包访问权限，不对外公开，实际只是用来对LinkedHashSet的支持，因为LinkedHashSet是基于LinkedHashMap实现的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加元素，就是将元素作为key放入HashMap：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移除元素，就是将map中的key移除：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断HashSet是否包含某个元素，就是判断HashMap是否包含某个key<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedHashSet">LinkedHashSet</h3><p><strong>底层实现</strong>：继承自HashSet，又基于LinkedHashMap来实现。<br><strong>顺序</strong>：元素本身无序存储，但是在迭代遍历时是按照插入顺序来遍历。</p>
<p>保存的元素本身是无序的，但是内部使用双向循环链表保存了元素的插入顺序，所以在迭代遍历的时候，顺序是插入时的顺序。（直接使用了LinkedHashMap来实现）</p>
<p>LinkedHashSet通过继承HashSet，底层使用LinkedHashMap来保存所有元素，其所有的方法与HashSet相同，因此LinkedHashSet以很简单的方式实现了其自身的所有功能（仅仅定义了4个构造函数）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应父类HashSet的构造函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    <span class="comment">// 底层使用LinkedHashMap来保存元素</span></span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LInkedHashSet的完整实现就以上代码，总结来说就是提供了4个构造函数，在构造函数中初始化了LinkedHashMap。<br>对于LInkedHashSet的所有操作都直接继承了HashSet，未做任何修改。<br>所以，LInkedHashSet与HashSet唯一不同的是，LInkedHashSet的内部是LinkedHashMap，而HashSet的内部则是HashMap。</p>
<h3 id="TreeSet">TreeSet</h3><p><strong>底层实现</strong>：红黑树（一种自平衡二叉树，可在O(log n)时间内做查找、插入和删除，n是树中元素的数目）<br><strong>排序</strong>：按照元素的排序顺序来保存元素（顺序由Comparable或Comparator决定）。<br><strong>优点</strong>：元素是有序的，同时具有不错的查询速度（O(log n)）。<br><strong>缺点</strong>：速度不如HashSet快。<br><strong>注意点</strong>：元素必须实现Comparable接口，或者在创建TreeSet的时候传入Comparator参数来指导排序，否则在程序运行时将抛出异常。（Java提供了一个Comparable接口，该接口定义了一个compareTo(Object obj)方法，实现了该接口的对象就可以比较大小）</p>
<p>TreeSet的底层实现非常的简单，使用TreeMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用TreeMap的key保存TreeSet中所有元素(TreeMap实现了NavigableMap接口)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E, Object&gt; m;</span><br><span class="line"><span class="comment">// 定义一个虚拟的Object对象作为TreeMap的value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>创建一个TreeSet的时候，就是在内部实例化了一个TreeMap，构造函数如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，底层会初始化一个TreeMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供排序对象comparator，来初始化一个TreeMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于另一个有序集来创建新的TreeSet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加元素，就是将元素作为key放入TreeMap：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移除元素，就是将TreeMap中的key移除：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断HashSet是否包含某个元素，就是判断TreeMap是否包含某个key<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2><ul>
<li>Java编程思想 第17章 容器深入研究</li>
<li>Jdk1.7 容器类源码</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/容器/">容器</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://qq2867234.github.io/2016/03/05/The-underlying-implementation-of-common-container/" data-title="Java常用容器的实现原理 | Shadow" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/03/14/Linux-service-manager/" title="Linux的服务管理">
  <strong>上一篇：</strong><br/>
  <span>
  Linux的服务管理</span>
</a>
</div>


<div class="next">
<a href="/2016/02/28/Commonly-used-MySQL/"  title="工作中常用SQL记录">
 <strong>下一篇：</strong><br/> 
 <span>工作中常用SQL记录
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/03/05/The-underlying-implementation-of-common-container/" data-title="Java常用容器的实现原理" data-url="http://qq2867234.github.io/2016/03/05/The-underlying-implementation-of-common-container/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器概念"><span class="toc-number">1.</span> <span class="toc-text">容器概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fail-fast"><span class="toc-number">2.1.1.</span> <span class="toc-text">fail-fast</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">2.2.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">3.2.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">3.3.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">4.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">4.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">4.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/MySQL/" title="MySQL">MySQL<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web/" title="Web">Web<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Jason. This is my blog on GitHub. <br/>
			Every day a little better than yesterday</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2609473321" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/qq2867234" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Shadow">Shadow</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(20,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    /*if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }*/
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(80,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"chenjiusheng"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
