<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shadow</title>
  <subtitle>Every day a little better than yesterday</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qq2867234.github.io/"/>
  <updated>2016-04-28T17:05:44.310Z</updated>
  <id>http://qq2867234.github.io/</id>
  
  <author>
    <name>Shadow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java常用容器的实现原理</title>
    <link href="http://qq2867234.github.io/2016/03/05/The-underlying-implementation-of-common-container/"/>
    <id>http://qq2867234.github.io/2016/03/05/The-underlying-implementation-of-common-container/</id>
    <published>2016-03-04T16:24:27.000Z</published>
    <updated>2016-04-28T17:05:44.310Z</updated>
    
    <content type="html">&lt;h2 id=&quot;容器概念&quot;&gt;容器概念&lt;/h2&gt;&lt;p&gt;容器就是我们常说的集合，那为什么要有一个新的名称呢？因为，Java的类库中使用了Collection来指代该类库的一个特殊子集，而Collection的中文又有集合的意思，所以为了避免混淆，使用了范围更广的术语“容器”来称呼。&lt;/p&gt;
&lt;p&gt;Java容器类的用途是“保存对象”，包含两大类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Collection&lt;/strong&gt;：保存一个独立元素的序列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt;：保存一组成对的“键值对”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是我们一般会说有4种容器：&lt;strong&gt;List、Set、Queue和Map&lt;/strong&gt;。它们各有2-3个实现版本。&lt;/p&gt;
&lt;p&gt;下面是容器类库的关系图（没有包括与同步相关的实现类）：&lt;br&gt;&lt;img src=&quot;http://7xtdiw.com1.z0.glb.clouddn.com/Java-Container.png&quot; alt=&quot;Java容器类库关系图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用容器用黑色粗线框表示。&lt;/li&gt;
&lt;li&gt;点线框表示接口。&lt;/li&gt;
&lt;li&gt;虚线框表示抽象类，大部分以Abstract开头，只是部分实现了特定接口的工具。&lt;/li&gt;
&lt;li&gt;实线框表示普通类。&lt;/li&gt;
&lt;li&gt;带有空心箭头的点线表示一个类实现了一个接口。&lt;/li&gt;
&lt;li&gt;带有实心箭头的点线表示某个类可以生成箭头所指向类的对象。&lt;/li&gt;
&lt;li&gt;实线表示一个类继承了另一个类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面错综复杂的类图，可以简单的总结为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个顶级接口：Collection和Map。而List、Set和Queue3个接口继承了Collection接口。&lt;/li&gt;
&lt;li&gt;Map与Collection没有关联，只不过Map内部提供方法可以生成Collection集合。&lt;/li&gt;
&lt;li&gt;Collection和Map都能生成一个迭代器Iterator，从而统一了容器的遍历方式。&lt;/li&gt;
&lt;li&gt;List接口常用的实现类：ArrayList和LinkedList。&lt;/li&gt;
&lt;li&gt;Map接口常用的实现类：HashMap、TreeMap和LinkedHashMap。&lt;/li&gt;
&lt;li&gt;Set接口常用的实现类：HashSet、TreeSet和LinkedHashSet。&lt;/li&gt;
&lt;li&gt;最后是容器操作的两大工具类：Collections和Arrays，提供了大量的静态方法来操作容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别介绍List、Map和Set的各个常用实现类：&lt;/p&gt;
&lt;h2 id=&quot;List&quot;&gt;List&lt;/h2&gt;&lt;p&gt;按元素的插入顺序来保存元素，允许元素重复，也允许null值。&lt;/p&gt;
&lt;h3 id=&quot;ArrayList&quot;&gt;ArrayList&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：数组&lt;br&gt;&lt;strong&gt;内部顺序&lt;/strong&gt;：下标顺序&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;：按数组下标访问、在数组末尾添加元素时性能高&lt;br&gt;&lt;strong&gt;缺点&lt;/strong&gt;：按下标插入、删除元素时性能低，因为要移动受影响的元素&lt;br&gt;&lt;strong&gt;关键点&lt;/strong&gt;：自动扩容。由于数组长度有限，当长度不够时能自动扩容，每次增加50%容量，用System.arraycopy()复制元素到新数组，因此可以的话最好指定数组的初始容量。&lt;/p&gt;
&lt;p&gt;基于数组实现。适合随机访问元素，但是插入和删除元素比较慢。&lt;/p&gt;
&lt;p&gt;ArrayList的底层使用对象数组elementData来保存元素：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 底层使用对象数组来保存元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Object[] elementData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实际保存的元素个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组默认的初始容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 保存数组被修改的次数（add remove等操作都会增加这个值），用在迭代遍历时防止数组被修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; modCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ArrayList提供了3种构造函数：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化为空数组，在第一次add的时候，才会构造一个默认初始容量为10的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在老的jdk版本中，创建的时候就初始化了一个容量为10的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elementData = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指定初始化容量来创建ArrayList&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 按指定的容量initialCapacity来初始化数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elementData = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object[initialCapacity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基于已有的集合创建ArrayList&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? extends E&amp;gt; c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将集合转换成对象数组，并将引用赋给elementData &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elementData = c.toArray();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将元素个数保存到size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size = elementData.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加元素：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 向数组尾部添加元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 确保数组的容量足够容纳新的元素，如果容纳不下，将进行扩容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ensureCapacityInternal(size + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将元素保存到数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elementData[size++] = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 向数组中的指定位置添加元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果当前位置有元素，则当前位置以及之后的所有元素，都向后移动一位，以腾出空位容纳新元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rangeCheckForAdd(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果数组容纳不下新元素，将进行扩容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ensureCapacityInternal(size + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将当前位置以及之后的所有元素，都向后移动一位（开销较大）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.arraycopy(elementData, index, elementData, index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, size - index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将元素保存到数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elementData[index] = element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ArrayList封装了ensureCapacityInternal()方法来确保数组的容量足够容纳新的元素，如果不足以容纳新的元素，将进行扩容：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ensureCapacityInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果数组是空的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (elementData == EMPTY_ELEMENTDATA) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这时候minCapacity其实就是1，所以下面的minCapacity会等于默认的初始容量DEFAULT_CAPACITY&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果需要的最小容量 大于 目前数组的容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 数组扩容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        grow(minCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数组进行扩容时，每次数组容量的增长大约是其原容量的1.5倍，同时会将老数组中的元素重新拷贝一份到新的数组中。这种操作的代价很高，因此在使用时，如果我们可预知要保存多少元素，最好在构造ArrayList实例时指定其容量，以免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。&lt;br&gt;下面是数组扩容方法：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;grow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 新的容量 = 原数组的容量 + 原数组的容量/2 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用Arrays工具类的copyOf方法，用新的容量创建新的数组，并复制旧的数组元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elementData = Arrays.copyOf(elementData, newCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获取元素，直接通过下标访问，速度很快：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rangeCheck(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 直接根据下标访问数组，所以速度很快&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (E) elementData[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除元素，涉及到移动元素，所以开销相对较大：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检查下标是否越界，越界则抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rangeCheck(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 修改次数+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取出旧的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    E oldValue = elementData(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算要移动的元素个数    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numMoved = size - index - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将被删除元素之后的所有元素，向前移动一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.arraycopy(elementData, index+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, elementData, index, numMoved);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将最后一位元素置为null，好让垃圾回收器清理没用的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elementData[--size] = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// clear to let GC do its work&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回被移除元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index &amp;gt;= size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;fail-fast&quot;&gt;fail-fast&lt;/h4&gt;&lt;p&gt;最后介绍一下fail-fast机制（快速失败机制），几乎所有的容器类在迭代遍历的时候，都采用了这种机制，这里以ArrayList为例进行介绍，后面将不再赘述。&lt;/p&gt;
&lt;p&gt;我们知道ArrayList不是线程安全的，因此如果在使用迭代器的过程中有其它线程修改了ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast。&lt;/p&gt;
&lt;p&gt;fail-fast机制在源码中的实现是通过modCount变量来完成，modCount记录了对ArrayList的修改次数，任何对ArrayList内容的修改都将增加这个值，在迭代器初始化过程中会将这个值保存在迭代器的expectedModCount变量中。&lt;br&gt;在迭代过程中，始终判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了ArrayList，立即抛出异常，终止迭代：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkForComodification&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;LinkedList&quot;&gt;LinkedList&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：双向链表&lt;br&gt;&lt;strong&gt;顺序&lt;/strong&gt;：节点串连顺序&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;：插入、删除元素时只要修改链表引用，不需要移动元素，虽然还需要遍历部分链表，但是相对ArrayList的移动元素来说，这部分开销可以忽略。&lt;br&gt;&lt;strong&gt;缺点&lt;/strong&gt;：按下标访问时需要遍历链表到指定的位置（时间复杂度O(n/2)）。占用更多空间。&lt;/p&gt;
&lt;p&gt;基于双向链表实现，在插入和删除元素时比ArrayList更加高效，但是随机访问相对较慢。&lt;br&gt;另外，LinkedList还添加了可以用作栈、队列或双端队列的方法。&lt;/p&gt;
&lt;p&gt;既然是基于链表，那就少不了节点，LinkedList中的节点类被定义为静态内部私有类Node：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存元素值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    E item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 指向下一个节点的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;E&amp;gt; next;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 指向上一个节点的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;E&amp;gt; prev;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.item = element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.prev = prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于双向链表的实现，保存了首、尾节点的引用：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指向首节点的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指向尾节点的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加元素到链表尾部：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先临时保存旧的尾节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建新节点，将旧的尾节点 作为 新节点的前一个节点(有点绕)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 然后将新节点作为尾节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    last = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果之前没有尾节点，说明是第一个元素，让新节点同时作为首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        first = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 否则，将新节点作为旧的尾节点的下一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        l.next = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获取元素，需要从头(或从尾)遍历链表，速度没有ArrayList快：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检查是否越界&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checkElementIndex(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据下标获取链表中的元素值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; node(index).item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据index判断是在前半区间还是后半区间，从而选择头开始遍历还是从尾开始遍历，将时间复杂度由O(n)变为O(n/2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Node&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下标小于容量的一半，从链首开始遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node&amp;lt;E&amp;gt; x = first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 跳过index个节点（随机访问的主要时间开销都在这）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; index; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x = x.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回指定的节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 否则，从链尾开始遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node&amp;lt;E&amp;gt; x = last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 跳过index个节点（随机访问的主要时间开销都在这）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = size - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;gt; index; i--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x = x.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回指定的节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkElementIndex&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(index &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index &amp;lt; size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除元素：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检查是否越界&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checkElementIndex(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据下标获取节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;E&amp;gt; node = node(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 移除指定的节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; unlink(node );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 移除指定节点，链表移除一个节点的时间复杂度为O(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;E &lt;span class=&quot;title&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node&amp;lt;E&amp;gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存要移除节点的元素值和前后节点引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; E element = x.item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next = x.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev = x.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果前一个节点的引用为null，说明移除的是首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (prev == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 让下一个节点成为新的首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        first = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 否则 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将要移除元素的后一个节点，作为上一个节点的下一个节点(有点绕，慢慢理解)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prev.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 然后再清除要移除元素的前一个节点引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x.prev = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 移除的是尾节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 让上一个节点成为新的尾节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last = prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 否则 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将要移除元素的前一个节点，作为下一个节点的上一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next.prev = prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x.next = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 要移除节点的元素值置为null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x.item = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Map&quot;&gt;Map&lt;/h2&gt;&lt;h3 id=&quot;HashMap&quot;&gt;HashMap&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：散列表，用链表解决碰撞问题（数组+散列函数+链表）。&lt;br&gt;&lt;strong&gt;顺序&lt;/strong&gt;：无序且不稳定，每次resize都会改变原有顺序。&lt;br&gt;&lt;strong&gt;关键点&lt;/strong&gt;：碰撞解决和resize。Jdk 7使用链表解决碰撞，在Jdk 8中，如果一个bucket中碰撞的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。添加键值对的时候，如果超过了负载因子所限制的容量，则会重新创建一个原来长度两倍的HashMap，并使用优化算法重新计算元素在bucket中的下标。&lt;br&gt;&lt;strong&gt;注意点&lt;/strong&gt;：如果要使用自定义的类来作为HashMap的键，必须同时重载hashCode()和equals()方法，否则将使用Object的hashCode()和equals()，这两个方法都是基于对象的地址来处理，直接导致无法正确处理你的键。&lt;br&gt;&lt;strong&gt;优化&lt;/strong&gt;：可以通过创建自己的Map来进一步提高查询速度，并且令新的Map只针对你使用的特定类型，这样可以避免与Object之间的类型转换操作。要达到更高的性能，可以参考Donald Knuth的The Art Of Computer Programming, Volume 3: Sorting and Searching, Second Edition。使用数组代替溢出桶，这有两个好处：1. 可以针对磁盘存储方式做优化； 2. 在创建和回收单独的记录时，能节约很多时间。&lt;/p&gt;
&lt;p&gt;基于Map接口实现、允许null键/值、非同步、不保证有序、也不保证序不随时间变化。&lt;/p&gt;
&lt;p&gt;HashMap的底层就是一个数组，数组中的每个元素都是一个链表，它保存了链表的首节点引用，链表的每个节点为键值对Entry&lt;k,v&gt;：&lt;br&gt;PS：很多人说，当没发生键碰撞时，数组中保存的是键值对，只有当键碰撞时，才会使用链表。其实底层的实现，并没有这个判断过程，无论键是否发送碰撞，都是用链表来保存键值对，只不过当没有发生键碰撞时，链表中只有一个节点。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 底层用数组保存键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 更准确的说法应该是：用数组保存链表的首节点，因为对于链表，只要有了首节点，就可以遍历整个链表，所以在这里只要将首节点引用保存在数组中即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;[] table = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认的初始容量16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 等于16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认的负载因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = &lt;span class=&quot;number&quot;&gt;0.75f&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实际的负载因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 键值对个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可负载容量：就是下一次要进行resize的容量（table.length*loadFactor）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;下面看看用来保存键值对的Entry&lt;k,v&gt;类，每个Entry&lt;k,v&gt;对象，才真正的保存了键值对数据，同时还持有指向下一个键值对的引用，这就构成了链表，用来解决键的碰撞问题：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Map&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    V value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 键碰撞发生时，指向下一个键值对，如果没有冲突则next为null。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/k,v&gt;&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;HashMap提供了4种构造函数：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用默认的初始容量16和默认的负载因子0.75来创建HashMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用指定的初始容量和默认的负载因子0.75来创建HashMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用指定的初始容量和指定的负载因子来创建HashMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果容量超过最大容量，则使用最大容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;gt; MAXIMUM_CAPACITY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        initialCapacity = MAXIMUM_CAPACITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.loadFactor = loadFactor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    threshold = initialCapacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 作为子类的初始化钩子函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个方法在HashMap中为空方法。在HashMap的子类(比如LinkedHashMap)中会覆盖该方法，从而执行子类需要的相关代码。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用已有的Map来创建新的HashMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据参数中map的键值对个数来计算需要的容量，并使用默认的负载因子，来创建HashMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(Math.max((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) (m.size() / DEFAULT_LOAD_FACTOR) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用指定容量初始化table(Entry数组)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    inflateTable(threshold);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将参数中map中的键值对放入新创建的table中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    putAllForCreate(m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 找到一个[&amp;gt;=number]的[2的倍数值]（8-&amp;gt;16; 15-&amp;gt;16; 16-&amp;gt;16; 17-&amp;gt;32）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;roundUpToPowerOf2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; number)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; number &amp;gt;= MAXIMUM_CAPACITY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ? MAXIMUM_CAPACITY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            : (number &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) ? Integer.highestOneBit((number - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inflateTable&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; toSize)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 找到一个&amp;gt;=toSize的2的倍数值，作为新的数组容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; capacity = roundUpToPowerOf2(toSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 可负载容量（总容量*负载因子，一旦达到可负载容量，就需要resize）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    threshold = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用指定容量初始化Entry数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    table = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry[capacity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initHashSeedAsNeeded(capacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;向HashMap中添加一个键值对的过程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先计算key的hash值&lt;/li&gt;
&lt;li&gt;根据hash值和数组长度，计算得到该key在数组中的存储位置（即数组下标）。&lt;/li&gt;
&lt;li&gt;创建新的键值对对象，并将其插入数组下标所指向的链表的头部。&lt;/li&gt;
&lt;li&gt;更新数组下标所指向的引用，将其指向新的链表头部。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// table还未初始化，则将其初始化为默认的容量大小16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (table == EMPTY_TABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inflateTable(threshold);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 允许null键，当key为null时，将其放在数组的第一个位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (key == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; putForNullKey(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算key的hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash = hash(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据hash值和数组长度，计算key在数组中的存储位置（即数组下标）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = indexFor(hash, table.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果数组下标i处的Entry不为null，则遍历该链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果在链表中找到重复的键值对，则将其替换为新的值，并返回旧的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            V oldValue = e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.recordAccess(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将键值对保存到数组的下标i中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addEntry(hash, key, value, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 计算hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h = hashSeed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果是字符串，用特殊的hash函数来计算hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; != h &amp;amp;&amp;amp; k &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sun.misc.Hashing.stringHash32((String) k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// hash算法    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    h ^= k.hashCode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    h ^= (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据hash值和数组的长度，计算指定hash在数组中的存储位置（即数组下标）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 计算该键值对应该保存在数组的哪个下标处&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;indexFor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个方法非常巧妙，它利用了HashMap底层数组的长度总是2的整数次方，从而可以用掩码来代替取模运算，消除取模运算带来的开销，提升效率。（这也是为什么每次扩容数组的时长度都是2的整数次方的原因）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h &amp;amp; (length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据hash值和数组下标，保存键值对到相应位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bucketIndex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果键值对个数已达到可负载容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; != table[bucketIndex])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将table数组的长度扩容到原来的2倍&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resize(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * table.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 再重新计算新的hash值和数组下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hash = (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; != key) ? hash(key) : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bucketIndex = indexFor(hash, table.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建键值对并保存到相应位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    createEntry(hash, key, value, bucketIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建键值对并将其保存到table数组的相应位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bucketIndex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先根据数组下标取出原的链表首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 再创建新的键值对，并将其内部的next引用指向原来的链表首节点，让其成为新的首节点，最后将新的首节点保存到table数组的指定下标中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// （将新的键值对插入链表的头部，作为链表首节点，并更新数组中原来的链表首节点）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    table[bucketIndex] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(hash, key, value, e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;关于上面的实现，有一点需要介绍一下：&lt;br&gt;之前，为了使散列分布均匀，数组的长度通常使用质数，因为这样能够减少键碰撞的概率。但是，后来事实证明，质数实际上并不是理想的数组长度，经过广泛的测试之后，Java的散列函数都改为使用2的整数次方，因为，对于现代的处理器来说，&lt;strong&gt;除法和求余数是最慢的操作，使用2的整数次方长度的数组，可用掩码来代替除法&lt;/strong&gt;。&lt;br&gt;因为get()是使用最多的操作，求余数的%操作是其开销最大的部分，而使用2的整数次方可以消除此开销。&lt;br&gt;（参考Java编程思想第4版 494页）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从HashMap中取出一个键值对的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先计算key的hash值&lt;/li&gt;
&lt;li&gt;再根据hash值计算出该key在数组中的下标&lt;/li&gt;
&lt;li&gt;最后取出该下标处的Entry，并返回对应的value&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...... &lt;span class=&quot;comment&quot;&gt;// 省略代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算key的hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash = hash(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据hash值和数组长度，计算得到数组下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = indexFor(hash, table.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历数组下标所指向的链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 使用key.equals()在链表中找到符合的键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(k))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 返回值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e.getValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 找不到，返回null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;HashMap 的 resize&lt;/strong&gt;（rehash）：&lt;br&gt;随着HashMap中键值对数量的增多，键的碰撞概率也随之增高，为了保证HashMap的查询效率，当键值对个数超过可负载容量时，就需要将数组的大小扩展为原来的2倍，然后重新计算每个元素在数组中的位置，这就是HashMap的resize。&lt;br&gt;这是一个非常消耗性能的操作，所以如果我们可以预先知道HashMap中键值对的个数，那么预设初始容量能够有效的提高HashMap的性能。&lt;br&gt;下面看看resize的实现：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用新的容量来扩展数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 原来的数组容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oldCapacity = table.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果原来已经达到了最大容量，则不再对数组进行扩容，而是将可负载的容量改为最大容量（相当于将负载因子从0.75置为1）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldCapacity == MAXIMUM_CAPACITY) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        threshold = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用新的容量初始化数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry[] newTable = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry[newCapacity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将原来的键值对保存到新的数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transfer(newTable, initHashSeedAsNeeded(newCapacity));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    table = newTable;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    threshold = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将原来的键值对保存到新的数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 所有原来的键值对对象都可以接着使用，不用重新创建新的键值对，需要改变的只它们之间的引用关系。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Entry[] newTable, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; rehash)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newCapacity = newTable.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历原来的Entry数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e : table) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历所指向的链表中的每个Entry&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; != e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 先保存下一个Entry，以便下一次循环中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Entry&amp;lt;K,V&amp;gt; next = e.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果需要重新计算hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rehash) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 重新计算hash值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.hash = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == e.key ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : hash(e.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重新计算新的数组下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = indexFor(e.hash, newCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// newTable[i]保存的是新数组中对应下标所指向的链表首节点引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 这里将e.next指向原来的首节点引用，这样e就成为了链表新的首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.next = newTable[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 将链表新的首节点引用e保存到新数组的指定下标ｉ中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 这上下两行代码，完美的使用链表来解决了碰撞问题（无论碰撞与否都用同样的方式来处理）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newTable[i] = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 将e指向下一个Entry，在下一轮循环中对其进行同样的处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么每次数组都是扩展为原来的2倍？&lt;br&gt;为了保证数组的容量始终为2的n次方，有了这个前提，就可以把根据hash值来计算数组下标的取模运算，转换为掩码运算，从而提高效率。&lt;br&gt;（因为在HashMap中，需要根据hash值来计算数组的下标，hash值通常都大于数组的长度，一般的做法是采用取模运算，而取模是很慢的操作，所以为了优化这个操作，使用2的n次方长度的数组，可用掩码来代替取模运算。 因为get()是使用最多的操作，其中取模操作是其开销最大的部分，而使用2的整数次方可以消除此开销。 ）&lt;/p&gt;
&lt;h3 id=&quot;LinkedHashMap&quot;&gt;LinkedHashMap&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：散列表+双向循环链表&lt;br&gt;&lt;strong&gt;顺序&lt;/strong&gt;：元素无序存放，但遍历时可以按照插入顺序或者最近访问顺序来遍历。&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;：在迭代访问时更快，可按插入顺序或访问顺序来遍历。&lt;br&gt;&lt;strong&gt;缺点&lt;/strong&gt;：需要额外维护双向循环链表来保存元素的迭代顺序。&lt;/p&gt;
&lt;p&gt;在HashMap的基础上，在内部使用双向循环链表维护元素的迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。这样可以使速度接近HashMap，同时又保持了迭代顺序。&lt;br&gt;保存的元素本身是无序的，但是在遍历的时候，可以元素的插入顺序或者是最近最少使用的顺序来遍历。&lt;br&gt;只比HashMap慢一点，而在迭代访问时反而更快，因为它使用双向循环链表维护内部顺序。&lt;/p&gt;
&lt;p&gt;LinkedHashMap继承自HashMap，通过重写父类相关方法，来实现自己的特性。&lt;/p&gt;
&lt;p&gt;添加了两个属性header和accessOrder：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 保存用来维护迭代顺序的双向循环链表的首节点，首节点不保存数据，内部的after指向第一个元素，before则指向最后一个元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; header;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 是否按照元素的访问顺序来排序，默认为false，按照插入顺序排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果为true，那么首先按照插入顺序排序，当某个元素被访问或修改时，会将其移到链表尾部，下次淘汰元素的时候从链首开始淘汰，这就是最近久未使用淘汰算法（LRU）。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; accessOrder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;重新定义了Entry&lt;k, v=&quot;&quot;&gt;类，继承自HashMap.Entry&lt;k,v&gt;，并添加了前后节点的引用，来实现双向循环链表：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存前后节点的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; before, after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 调用父类的构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, HashMap.Entry&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(hash, key, value, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/k,v&gt;&lt;/k,&gt;&lt;/p&gt;
&lt;p&gt;添加一个键值对：&lt;br&gt;LinkedHashMap直接使用HashMap的put方法来添加一个键值对，但是重写了HashMap的addEntry和createEntry方法，来提供特有的双向循环链表实现：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加一个键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bucketIndex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先调用了父类的addEntry方法，在方法中判断是否要进行resize，再调用createEntry&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.addEntry(hash, key, value, bucketIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果需要的话，删除最近最少使用的键值对  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; eldest = header.after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在LinkedHashMap中，removeEldestEntry()方法永远返回false，因为它默认不移除旧的键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (removeEldestEntry(eldest)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        removeEntryForKey(eldest.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建键值对并将其保存到table数组的相应位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bucketIndex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先根据数组下标取出原来的链表首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HashMap.Entry&amp;lt;K,V&amp;gt; old = table[bucketIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建新的键值对e，并将e.next引用指向原来的首节点，让e成为新的首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; e = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(hash, key, value, old);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将e作为新的首节点，保存到table数组的指定下标中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    table[bucketIndex] = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这是与HashMap中createEntry方法唯一不同的地方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在首节点之前插入一个节点，因为是双向循环链表，就相当于插于在链尾插入一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e.addBefore(header);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在指定节点前插入一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addBefore&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Entry&amp;lt;K,V&amp;gt; existingEntry)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    after  = existingEntry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    before = existingEntry.before;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    before.after = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    after.before = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认返回false，不移除任何键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map.Entry&amp;lt;K,V&amp;gt; eldest)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获取一个键值对：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据key获取键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;)getEntry(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (e == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果启用了访问排序，则记录访问顺序；否则不做任何操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e.recordAccess(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; getEntry(Object key) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash = (key == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : hash(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         e != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 根据key获取对应键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(k))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果启用了访问排序，则记录访问顺序，将最新访问的元素移到链表尾部（链表是按访问顺序排序，最近访问的元素放末尾）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 否则不做任何操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;recordAccess&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(HashMap&amp;lt;K,V&amp;gt; m)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkedHashMap&amp;lt;K,V&amp;gt; lm = (LinkedHashMap&amp;lt;K,V&amp;gt;)m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果定义了LinkedHashMap的迭代顺序为访问顺序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lm.accessOrder) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lm.modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将当前节点移到链表尾部&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        before.after = after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        after.before = before;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addBefore(lm.header);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于LinkedHashMap构建LRU缓存（最近最少使用算法）：&lt;/p&gt;
&lt;p&gt;前面已经介绍过，在创建LInkedHashMap的时候将accessOrder置为true，此时元素的迭代顺序就是其访问顺，另外LinkedHashMap还提供了removeEldestEntry(Map.Entry&lt;k,v&gt; eldest)方法，在插入新的元素后，put将调用此方法，根据此方法的返回值来决定是否删除最久未使用的元素，默认返回false，即永远不删除旧的元素。&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;所以，基于LInkedHashMap来构建LRU缓存将非常方便，只需要继承LInkedHashMap，并重写removeEldestEntry方法，在方法中定义淘汰规则即可，比如希望只保存100个最近使用的元素，超过100个后，每次添加新的元素将删除最旧的元素，则实现如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LRUCache&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MAX_ENTRIES&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map.Entry eldest)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size() &amp;gt; MAX_ENTRIES;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;TreeMap&quot;&gt;TreeMap&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：红黑树（一种自平衡二叉树，可在O(log n)时间内做查找、插入和删除，n是树中元素的数目）&lt;br&gt;&lt;strong&gt;排序&lt;/strong&gt;：按照元素的排序顺序来保存元素（顺序由Comparable或Comparator决定）。&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;：元素是有序的，同时具有不错的查询速度（O(log n)）。&lt;br&gt;&lt;strong&gt;缺点&lt;/strong&gt;：速度不如HashMap快。&lt;br&gt;&lt;strong&gt;注意点&lt;/strong&gt;：元素必须实现Comparable接口，或者在创建TreeMap的时候传入Comparator参数来指导排序，否则在程序运行时将抛出异常。（Java提供了一个Comparable接口，该接口定义了一个compareTo(Object obj)方法，实现了该接口的对象就可以比较大小）&lt;/p&gt;
&lt;p&gt;在TreeMap中保存了一个root节点，是红黑树的根节点：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 红黑树的根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; root = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;TreeMap提供了与其它Map不同的Entry&lt;k,v&gt;实现类：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 红黑树的节点类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Map&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    V value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 左子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; left = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 右子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; right = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 父节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; parent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 节点的颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; color = BLACK;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry(K key, V value, Entry&amp;lt;K,V&amp;gt; parent) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.parent = parent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; RED   = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; BLACK = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;TreeMap提供了如下几个构造函数：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    comparator = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 提供自定义的comparator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparator&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt; comparator)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.comparator = comparator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    comparator = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    putAll(m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加一个键值对，按照顺序插入红黑树的相应位置：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; t = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果根节点为null，则初始化根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 好像没什么用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        compare(key, key); &lt;span class=&quot;comment&quot;&gt;// type (and possibly null) check&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建新的节点，作为根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(key, value, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 比较结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存父节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; parent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 区分是使用 comparator 还是 comparable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Comparator&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt; cpr = comparator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果定义了comparator（在创建TreeMap的时候作为参数传入），则使用comparator来进行比较&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cpr != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历红黑色，找到合适的位置插入新节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 保存当前节点为父节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            parent = t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 比较插入的新key与当前所比较节点的key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cmp = cpr.compare(key, t.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 新key小于当前节点key，进入左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t = t.left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 新key大于当前节点key，进入左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t = t.right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// key值相等，则使用新的value替换旧的value，结束。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t.setValue(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (t != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 否则使用Comparable来进行比较（此时要求作为Key的类必须实现Comparable接口并重写compareTo方法，否则将抛出异常）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (key == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Comparable&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt;) key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历红黑色，找到合适的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 保存当前节点，在循环结束后用来作为新节点的父节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            parent = t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 比较插入的新key与当前所比较节点的key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cmp = k.compareTo(t.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 新key小于当前节点key，进入左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t = t.left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 新key大于当前节点key，进入左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t = t.right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// key值相等，则使用新的value替换旧的value，结束。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t.setValue(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (t != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行到这里，说明已找到新节点的插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建一个新的节点，并将前面找到的节点作为新节点的父节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; e = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(key, value, parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 新key值小于父节点key值，作为左子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parent.left = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 新key值大于父节点key值，作为右子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parent.right = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 红黑树的平衡调整（这才是红黑树最关键，也是最复杂的地方，在这里就不介绍了，因为我也不懂...）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fixAfterInsertion(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获取一个键值对，在红黑树中从根节点开始往下查找，直到找到对应值：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; p = getEntry(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (p==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; : p.value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; getEntry(Object key) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果定义了Comparator，则使用Comparator进行比较，过程与接下来的代码基本一致&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (comparator != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; getEntryUsingComparator(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (key == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将key向上转型为Comparable接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Comparable&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; K&amp;gt;) key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; p = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从根节点开始向下遍历子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (p != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 比较要查找的key与当前节点的key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cmp = k.compareTo(p.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果要查找的key小于当前节点的key，则进入左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p.left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果要查找的key大于当前节点的key，则进入右子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p.right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 找到key，返回节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Set&quot;&gt;Set&lt;/h2&gt;&lt;p&gt;不保存重复的元素，元素的排序方式在不同实现类之间有所不同。&lt;br&gt;因为要保证元素是唯一的，所以插入Set的元素必须定义equals()方法来确保对象的唯一性，否则将使用Object的equals()方法，而它比较的是对象的地址。&lt;/p&gt;
&lt;h3 id=&quot;HashSet&quot;&gt;HashSet&lt;/h3&gt;&lt;p&gt;基于HashMap实现。为快速查找而设计。&lt;br&gt;保存的元素是无序的（根据元素的hashCode值来决定元素的存储位置，所以可以认为是无序）。&lt;br&gt;如果元素是自定义的类，必须定义hashCode()方法，否则将使用Object的hashCode()，而它默认使用对象的地址来计算散列值，这明显不是我们想要的结果。&lt;/p&gt;
&lt;p&gt;HashSet的底层实现非常的简单，使用HashMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用HashMap的key保存HashSet中所有元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; HashMap&amp;lt;E,Object&amp;gt; map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个虚拟的Object对象作为HashMap的value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Object PRESENT = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个HashSet的时候，就是在内部实例化了一个HashMap，构造函数如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认构造函数，底层会初始化一个HashMap &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以指定的初始容量创建HashSet ，其实就是以相应的参数创建HashMap &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(initialCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以指定的初始容量和负载因子创建HashSet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? extends E&amp;gt; c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(Math.max((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) (c.size()/.&lt;span class=&quot;number&quot;&gt;75f&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addAll(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，HashSet还有个特殊的构造函数，为包访问权限，不对外公开，实际只是用来对LinkedHashSet的支持，因为LinkedHashSet是基于LinkedHashMap实现的：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HashSet(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; dummy) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加元素，就是将元素作为key放入HashMap：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map.put(e, PRESENT)==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除元素，就是将map中的key移除：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map.remove(o)==PRESENT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;判断HashSet是否包含某个元素，就是判断HashMap是否包含某个key&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map.containsKey(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;LinkedHashSet&quot;&gt;LinkedHashSet&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：继承自HashSet，又基于LinkedHashMap来实现。&lt;br&gt;&lt;strong&gt;顺序&lt;/strong&gt;：元素本身无序存储，但是在迭代遍历时是按照插入顺序来遍历。&lt;/p&gt;
&lt;p&gt;保存的元素本身是无序的，但是内部使用双向循环链表保存了元素的插入顺序，所以在迭代遍历的时候，顺序是插入时的顺序。（直接使用了LinkedHashMap来实现）&lt;/p&gt;
&lt;p&gt;LinkedHashSet通过继承HashSet，底层使用LinkedHashMap来保存所有元素，其所有的方法与HashSet相同，因此LinkedHashSet以很简单的方式实现了其自身的所有功能（仅仅定义了4个构造函数）。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; class LinkedHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;, .&lt;span class=&quot;number&quot;&gt;75f&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(initialCapacity, .&lt;span class=&quot;number&quot;&gt;75f&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(initialCapacity, loadFactor, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? extends E&amp;gt; c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(Math.max(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*c.size(), &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), .&lt;span class=&quot;number&quot;&gt;75f&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addAll(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对应父类HashSet的构造函数为：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HashSet(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; loadFactor, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; dummy) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 底层使用LinkedHashMap来保存元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;LInkedHashSet的完整实现就以上代码，总结来说就是提供了4个构造函数，在构造函数中初始化了LinkedHashMap。&lt;br&gt;对于LInkedHashSet的所有操作都直接继承了HashSet，未做任何修改。&lt;br&gt;所以，LInkedHashSet与HashSet唯一不同的是，LInkedHashSet的内部是LinkedHashMap，而HashSet的内部则是HashMap。&lt;/p&gt;
&lt;h3 id=&quot;TreeSet&quot;&gt;TreeSet&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;：红黑树（一种自平衡二叉树，可在O(log n)时间内做查找、插入和删除，n是树中元素的数目）&lt;br&gt;&lt;strong&gt;排序&lt;/strong&gt;：按照元素的排序顺序来保存元素（顺序由Comparable或Comparator决定）。&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;：元素是有序的，同时具有不错的查询速度（O(log n)）。&lt;br&gt;&lt;strong&gt;缺点&lt;/strong&gt;：速度不如HashSet快。&lt;br&gt;&lt;strong&gt;注意点&lt;/strong&gt;：元素必须实现Comparable接口，或者在创建TreeSet的时候传入Comparator参数来指导排序，否则在程序运行时将抛出异常。（Java提供了一个Comparable接口，该接口定义了一个compareTo(Object obj)方法，实现了该接口的对象就可以比较大小）&lt;/p&gt;
&lt;p&gt;TreeSet的底层实现非常的简单，使用TreeMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用TreeMap的key保存TreeSet中所有元素(TreeMap实现了NavigableMap接口)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; NavigableMap&amp;lt;E, Object&amp;gt; m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个虚拟的Object对象作为TreeMap的value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Object PRESENT = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个TreeSet的时候，就是在内部实例化了一个TreeMap，构造函数如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认构造函数，底层会初始化一个TreeMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;E,Object&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 提供排序对象comparator，来初始化一个TreeMap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparator&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; E&amp;gt; comparator)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;(comparator));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基于另一个有序集来创建新的TreeSet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SortedSet&amp;lt;E&amp;gt; s)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(s.comparator());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addAll(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加元素，就是将元素作为key放入TreeMap：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m.put(e, PRESENT)==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除元素，就是将TreeMap中的key移除：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m.remove(o)==PRESENT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;判断HashSet是否包含某个元素，就是判断TreeMap是否包含某个key&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m.containsKey(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java编程思想 第17章 容器深入研究&lt;/li&gt;
&lt;li&gt;Jdk1.7 容器类源码&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;容器概念&quot;&gt;容器概念&lt;/h2&gt;&lt;p&gt;容器就是我们常说的集合，那为什么要有一个新的名称呢？因为，Java的类库中使用了Collection来指代该类库的一个特殊子集，而Collection的中文又有集合的意思，所以为了避免混淆，使用了范围更广的术语“容器”来称呼。&lt;
    
    </summary>
    
      <category term="Java" scheme="http://qq2867234.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://qq2867234.github.io/tags/Java/"/>
    
      <category term="容器" scheme="http://qq2867234.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>工作中常用SQL记录</title>
    <link href="http://qq2867234.github.io/2016/02/28/Commonly-used-MySQL/"/>
    <id>http://qq2867234.github.io/2016/02/28/Commonly-used-MySQL/</id>
    <published>2016-02-28T15:07:17.000Z</published>
    <updated>2016-05-01T14:58:37.216Z</updated>
    
    <content type="html">&lt;p&gt;下面的SQL会用到表：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE demo (&amp;#10;    id int(11) NOT NULL AUTO_INCREMENT,&amp;#10;    name varchar(32) DEFAULT NULL,&amp;#10;    PRIMARY KEY (id)&amp;#10;) DEFAULT CHARSET=utf8;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;去重&quot;&gt;去重&lt;/h3&gt;&lt;p&gt;比如要根据name字段去重，并保留id最小的记录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;br&gt;先在子查询中查询要保留的记录，然后在外层关联原表，删除与子查询结果中name相等，但是id不相等的记录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DELETE t1 FROM demo t1, (&amp;#10;    SELECT id, name FROM demo GROUP BY name&amp;#10;) t2&amp;#10;WHERE t1.name = t2.name AND t1.id &amp;#60;&amp;#62; t2.id;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的SQL，由于GROUP BY 的原理，在子查询中保留下来的是id最小的记录，所以在外层就把所有name相等但是id大的记录给删了。&lt;br&gt;如果想要保留id最大的记录，上面的方法就不适用了，需要用下面的写法，先按照需要的顺序排好序，再GROUP BY，才能在子查询中保留id最大的记录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DELETE t1 FROM demo t1, (&amp;#10;    SELECT id, name FROM (&amp;#10;        SELECT id, name FROM demo ORDER BY id DESC&amp;#10;    ) t GROUP BY name&amp;#10;) t2&amp;#10;WHERE t1.name = t2.name AND t1.id &amp;#60;&amp;#62; t2.id;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;br&gt;表自身关联&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DELETE t1 &amp;#10;FROM demo t1, demo t2&amp;#10;WHERE t1.name = t2.name AND t1.id &amp;#62; t2.id;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;日期时间处理&quot;&gt;日期时间处理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;时间格式化&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- 2015-09-09 09:09:09&amp;#10;DATE_FORMAT(now(),&amp;#34;%Y-%m-%d %H:%i:%s&amp;#34;)&amp;#10;-- 15-9-9 9:09:09&amp;#10;DATE_FORMAT(now(),&amp;#34;%y-%c-%e %k:%i:%s&amp;#34;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日期时间差&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算日期差&lt;br&gt;（注：前面的日期 减 后面的日期）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DATEDIFF(expr1, expr2)&amp;#10;DATEDIFF(now(), &amp;#39;2015-09-09&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算时间差（可以计算任意类型的差值，比如：年数差、月份差、日差、时差等）&lt;br&gt;（注：后面的时间戳 减 前面的时间戳）&lt;br&gt;unit的单位可指定为：YEAR、MONTH、DAY、WEEK、HOUR、MINUTE、SECOND。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TIMESTAMPDIFF(unit, datetime_expr1, datetime_expr2)&amp;#10;TIMESTAMPDIFF(DAY, &amp;#39;2015-09-09&amp;#39;, now())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;计算指定间隔的另一个时间&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DATE_SUB(date, INTERVAL expr type)&amp;#10;DATE_ADD(date, INTERVAL expr type)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明：date是一个日期；expr是时间间隔；type是时间间隔的单位，其值可是下列值：&lt;br&gt;    YEAR、MONTH、DAY、WEEK、HOUR、MINUTE、SECOND、MICROSECOND 等。&lt;br&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10&amp;#20998;&amp;#38047;&amp;#21069;&amp;#65306;DATE_SUB(NOW(),INTERVAL 10 MINUTE)&amp;#10;10&amp;#20998;&amp;#38047;&amp;#21518;&amp;#65306;DATE_ADD(NOW(),INTERVAL 10 MINUTE)&amp;#10;1&amp;#22825;&amp;#21069;&amp;#65306;   DATE_SUB(NOW(),INTERVAL 1 DAY)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串处理&quot;&gt;字符串处理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;从左开始截取字符串&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LEFT(str, length)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从右开始截取字符串&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RIGHT(str, length)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;截取字符串&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SUBSTRING(str, pos)&amp;#10;SUBSTRING(str, pos, length)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（注：如果位置pos是负数 如-5 则是从后倒数，到字符串结束或指定截取的长度） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按分隔符截取字符串&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SUBSTRING_INDEX(str, delim, count)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明：substring_index（被截取字段，分隔符，分隔符出现的次数）&lt;br&gt;（注：如果“分隔符出现的次数”是负数，如-1，则分隔符从末尾开始倒数，截取到字符串结束）&lt;br&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT SUBSTRING_INDEX(&amp;#34;demo(hello)(world)demo&amp;#34;, &amp;#39;(&amp;#39;, 1);&amp;#10;&amp;#32467;&amp;#26524;&amp;#65306;demo&amp;#65288;&amp;#34920;&amp;#31034;&amp;#20174;&amp;#22836;&amp;#24320;&amp;#22987;&amp;#25130;&amp;#21462;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#21040;&amp;#31532;1&amp;#20010;&amp;#20998;&amp;#38548;&amp;#31526;&amp;#39;(&amp;#39;&amp;#20026;&amp;#27490;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#32467;&amp;#26524;&amp;#26159;demo&amp;#65289;&amp;#10;SELECT SUBSTRING_INDEX(&amp;#34;demo(hello)(world)demo&amp;#34;, &amp;#39;(&amp;#39;, 2);&amp;#10;&amp;#32467;&amp;#26524;&amp;#65306;demo(hello)&amp;#10;SELECT SUBSTRING_INDEX(&amp;#34;demo(hello)(world)demo&amp;#34;, &amp;#39;(&amp;#39;, -1);&amp;#10;&amp;#32467;&amp;#26524;&amp;#65306;world)demo&amp;#65288;&amp;#34920;&amp;#31034;&amp;#20174;&amp;#22836;&amp;#24320;&amp;#22987;&amp;#25130;&amp;#21462;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#21040;&amp;#31532;1&amp;#20010;&amp;#20998;&amp;#38548;&amp;#31526;&amp;#39;(&amp;#39;&amp;#20026;&amp;#27490;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#32467;&amp;#26524;&amp;#26159;demo&amp;#65289;&amp;#10;SELECT SUBSTRING_INDEX(&amp;#34;demo(hello)(world)demo&amp;#34;, &amp;#39;(&amp;#39;, -2);&amp;#10;&amp;#32467;&amp;#26524;&amp;#65306;hello)(world)demo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###提取字符串括号内的子串&lt;br&gt;比如一个字符串：金泉时代广场(保利金泉)，想要提起取括号内的“保利金泉”，用下面的SQL即可：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#19981;&amp;#20445;&amp;#30041;&amp;#25324;&amp;#21495;&amp;#65306;&amp;#10;LEFT(RIGHT(name, CHAR_LENGTH(name)-LOCATE(&amp;#39;(&amp;#39;,name)) ,LOCATE(&amp;#39;)&amp;#39;,RIGHT(name, CHAR_LENGTH(name)-LOCATE(&amp;#39;(&amp;#39;,name) - 1)))&amp;#10;&amp;#20445;&amp;#30041;&amp;#25324;&amp;#21495;&amp;#65306;&amp;#10;LEFT(RIGHT(name, CHAR_LENGTH(name)-LOCATE(&amp;#39;(&amp;#39;,name) + 1) ,LOCATE(&amp;#39;)&amp;#39;,RIGHT(name, CHAR_LENGTH(name)-LOCATE(&amp;#39;(&amp;#39;,name) + 1)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算两点的直线距离&quot;&gt;计算两点的直线距离&lt;/h3&gt;&lt;p&gt;假设有两个点，分别来自表a(longitude, latitude)和表b(longitude, latitude)，则两点的距离公式为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;round(12742000*asin(sqrt(pow(sin((a.latitude-b.latitude)*0.017453)/2,2)+cos(a.latitude*0.017453)*cos(b.latitude*0.017453)*pow(sin((a.longitude-b.longitude)*0.017453)/2,2))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明：上面的SQL中，表a的经纬度&lt;/p&gt;
&lt;h3 id=&quot;将分组内某字段的值进行串联&quot;&gt;将分组内某字段的值进行串联&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT GROUP_CONCAT(id ORDER BY id DESC) FROM demo GROUP BY name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;行列转换&quot;&gt;行列转换&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;列转行&lt;/strong&gt;&lt;br&gt;这里需要用到一张序列表，只有一个id字段，保存1-2-3-…-n的一个序列，n的大小视情况而定，这里让n为100。&lt;br&gt;假设有下面一行记录：&lt;br&gt;|  id  |   name    |&lt;br&gt;| :—:| :——-: |&lt;br&gt;|  1   |  a,b,c,d  |&lt;br&gt;要将其转换为下面的多行记录：&lt;br&gt;|  id  |  name  |&lt;br&gt;| :—:| :—-: |&lt;br&gt;|  1   |    a   |&lt;br&gt;|  1   |    b   |&lt;br&gt;|  1   |    c   |&lt;br&gt;|  1   |    d   |&lt;/p&gt;
&lt;p&gt;通过下面的SQL即可完成：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT b.id,&amp;#10;    REPLACE(SUBSTRING(SUBSTRING_INDEX(name,&amp;#39;,&amp;#39;,a.id),CHARACTER_LENGTH(SUBSTRING_INDEX(name,&amp;#39;,&amp;#39;,a.id-1))+1),&amp;#39;,&amp;#39;,&amp;#39;&amp;#39;) name&amp;#10;FROM tb_sequence a&amp;#10;CROSS JOIN (&amp;#10;    SELECT id, CONCAT(name,&amp;#39;,&amp;#39;) name, LENGTH(name)-LENGTH(REPLACE(name, &amp;#39;,&amp;#39;, &amp;#39;&amp;#39;))+1 size&amp;#10;    FROM demo b&amp;#10;) b ON a.id &amp;#60;= b.size;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行转列&lt;/strong&gt;&lt;br&gt;使用sum(case when … then … end) as … 来完成：&lt;br&gt;假设有下面多行记录：&lt;br&gt;|  year  |  month | price |&lt;br&gt;| :—–:| :—-: | :—: |&lt;br&gt;|  2016  |   1    |  1000 |&lt;br&gt;|  2016  |   2    |  2000 |&lt;br&gt;|  2016  |   3    |  3000 |&lt;br&gt;|  2016  |   4    |  4000 |&lt;br&gt;|  2016  |   5    |  5000 |&lt;br&gt;|  2016  |   6    |  6000 |&lt;/p&gt;
&lt;p&gt;要将其转换为下面的单行记录：&lt;br&gt;|  月份  | 2016年1月 | 2016年2月 | 2016年3月 | 2016年4月 | 2016年5月 | 2016年6月 |&lt;br&gt;| :—-:| :—–: | :—–: | :—–: | :—-: | :—-: | :—-: |&lt;br&gt;| 销售额 |  1000   |  2000   |  3000   |  4000  |  5000  |  6000  |&lt;/p&gt;
&lt;p&gt;通过下面的SQL即可完成：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT &amp;#39;&amp;#38144;&amp;#21806;&amp;#39069;&amp;#39; &amp;#26376;&amp;#20221; ,&amp;#10;    SUM(CASE WHEN month=1 THEN price END) AS &amp;#39;1&amp;#26376;&amp;#39;,&amp;#10;    SUM(CASE WHEN month=2 THEN price END) AS &amp;#39;2&amp;#26376;&amp;#39;,&amp;#10;    SUM(CASE WHEN month=3 THEN price END) AS &amp;#39;3&amp;#26376;&amp;#39;,&amp;#10;    SUM(CASE WHEN month=4 THEN price END) AS &amp;#39;4&amp;#26376;&amp;#39;,&amp;#10;    SUM(CASE WHEN month=5 THEN price END) AS &amp;#39;5&amp;#26376;&amp;#39;,&amp;#10;    SUM(CASE WHEN month=6 THEN price END) AS &amp;#39;6&amp;#26376;&amp;#39;&amp;#10;FROM demo;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;分组选择最大值&quot;&gt;分组选择最大值&lt;/h3&gt;&lt;p&gt;下面的SQL要实现的功能：保留名字重复记录中id最大的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先在子查询中排序，然后再分组&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT id, name FROM (&amp;#10;    SELECT id, name FROM demo ORDER BY id DESC&amp;#10;) t GROUP BY name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先Distinct，再子查询&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT name,&amp;#10;    (SELECT id FROM demo t2 WHERE t1.name = t2.name ORDER BY t2.id DESC LIMIT 1) AS id&amp;#10;FROM (&amp;#10;    SELECT DISTINCT name FROM demo&amp;#10;) t1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;利用自定义变量，先对数据进行排序，再按顺序对组内记录进行编号。 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT id, name FROM (&amp;#10;    SELECT id, name,&amp;#10;        -- &amp;#20026;&amp;#37325;&amp;#22797;&amp;#30340;&amp;#23383;&amp;#27573;&amp;#32534;&amp;#21495;&amp;#10;        (CASE WHEN name = @curName THEN @curRow := @curRow + 1 ELSE @curRow := 1 AND @curName := name END ) AS cnt&amp;#10;    FROM (&amp;#10;        -- &amp;#25353;&amp;#29031;&amp;#38656;&amp;#35201;&amp;#30340;&amp;#39034;&amp;#24207;&amp;#25490;&amp;#24207;&amp;#65288;&amp;#37325;&amp;#22797;&amp;#23383;&amp;#27573;&amp;#24517;&amp;#39035;&amp;#26159;&amp;#25490;&amp;#24207;&amp;#23383;&amp;#27573;&amp;#30340;&amp;#31532;&amp;#19968;&amp;#21015;&amp;#65289;&amp;#10;        SELECT id, name FROM demo ORDER BY name, id DESC&amp;#10;    ) t1, (&amp;#10;        SELECT @curRow := 0, @curName := &amp;#39;&amp;#39;&amp;#10;    ) t2&amp;#10;) t&amp;#10;WHERE t.cnt = 0;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分组选择TopN&quot;&gt;分组选择TopN&lt;/h3&gt;&lt;p&gt;有如下数据：&lt;br&gt;|   id  |   rid |  price  |&lt;br&gt;| :—: | :—-:| :—–: |&lt;br&gt;|   1   |   1   |   4500  |&lt;br&gt;|   2   |   1   |   4500  |&lt;br&gt;|   3   |   1   |   4100  |&lt;br&gt;|   4   |   1   |   4000  |&lt;br&gt;|   5   |   1   |   4000  |&lt;br&gt;|   6   |   1   |   4300  |&lt;br&gt;|   7   |   1   |   4200  |&lt;br&gt;|   8   |   2   |   4000  |&lt;br&gt;|   9   |   2   |   4500  |&lt;br&gt;|  10   |   2   |   3500  |&lt;br&gt;|  11   |   2   |   3800  |&lt;br&gt;|  12   |   2   |   3300  |&lt;br&gt;|  13   |   2   |   4400  |&lt;br&gt;|  14   |   2   |   3000  |&lt;br&gt;要查询每个rid下，price最高的前5条记录，下面是两种实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用子查询对记录进行编号&lt;br&gt;原理是扫描所有行，然后利用子查询，对于每一行，再次查询相同表，根据指定的排序条件查询比当前行price大的记录总数，作为该记录的排名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT rid, price, cnt FROM (&amp;#10;    SELECT id, rid, price,&amp;#10;        (SELECT count(*) FROM demo b WHERE a.rid = b.rid &amp;#10;            AND (a.price &amp;#60; b.price OR (a.price = b.price AND a.id &amp;#60; b.id) )) cnt&amp;#10;    FROM demo&amp;#10;) t&amp;#10;WHERE t.cnt &amp;#60; 5&amp;#10;ORDER BY rid, cnt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用自定义变量&lt;br&gt;先对结果进行排序，然后再使用自定义的变量对记录进行排名。相对于前面的方式来说，不需要使用子查询。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT rid, price, cnt FROM( &amp;#10;    SELECT rid, price, &amp;#10;        (CASE rid WHEN @curID THEN @curRow := @curRow + 1 ELSE @curRow := 1 AND @curID := rid END ) AS cnt    &amp;#10;    FROM (&amp;#10;        -- &amp;#25353;&amp;#29031;&amp;#38656;&amp;#35201;&amp;#30340;&amp;#39034;&amp;#24207;&amp;#25490;&amp;#24207;&amp;#65288;&amp;#29992;&amp;#26469;&amp;#20998;&amp;#32452;&amp;#30340;&amp;#23383;&amp;#27573;&amp;#24517;&amp;#39035;&amp;#26159;&amp;#25490;&amp;#24207;&amp;#23383;&amp;#27573;&amp;#30340;&amp;#31532;&amp;#19968;&amp;#21015;&amp;#65289;&amp;#10;        SELECT rid, price &amp;#10;        FROM demo&amp;#10;        ORDER BY rid, price DESC &amp;#10;    ) t1, (&amp;#10;        SELECT @curRow := 0, @curID := 0&amp;#10;    ) t2&amp;#10;) t&amp;#10;where t.cnt &amp;#60;= 5;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;下面的SQL会用到表：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE demo (&amp;#10;    id int(11)
    
    </summary>
    
      <category term="MySQL" scheme="http://qq2867234.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://qq2867234.github.io/tags/MySQL/"/>
    
      <category term="常用SQL" scheme="http://qq2867234.github.io/tags/%E5%B8%B8%E7%94%A8SQL/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能的索引</title>
    <link href="http://qq2867234.github.io/2016/02/24/Create-high-performance-index/"/>
    <id>http://qq2867234.github.io/2016/02/24/Create-high-performance-index/</id>
    <published>2016-02-24T15:07:17.000Z</published>
    <updated>2016-04-28T16:38:36.730Z</updated>
    
    <content type="html">&lt;p&gt;索引是存储引擎用于&lt;strong&gt;高效获取数据&lt;/strong&gt;的一种&lt;strong&gt;数据结构&lt;/strong&gt;，索引其实就是一种数据结构。索引对于良好的性能非常关键，索引优化是对查询性能优化最有效的手段。&lt;/p&gt;
&lt;h2 id=&quot;索引基础&quot;&gt;索引基础&lt;/h2&gt;&lt;p&gt;要理解索引是如何工作，最简单的方法就是去看一本书的目录：如果想在一本书中找到特定的章节，我们不会去翻阅整本书来找出这个章节，这样效率很低，我们肯定会先看目录，找到对应的页码，然后直接翻到指定页码。&lt;/p&gt;
&lt;p&gt;MySQL的存储引擎也是用类似的方法使用索引：先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。&lt;/p&gt;
&lt;p&gt;索引可以包含一个或多个列。MySQL只能高效的使用索引的&lt;strong&gt;最左前缀列&lt;/strong&gt;，所以当索引包含多个列的时候，列的顺序十分重要。&lt;/p&gt;
&lt;h2 id=&quot;索引的类型&quot;&gt;索引的类型&lt;/h2&gt;&lt;p&gt;在MySQL中，索引是在存储引擎层，而不是服务器层实现。所以，不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。&lt;/p&gt;
&lt;p&gt;下面是MySQL支持的索引类型，以及各自的优缺点。&lt;/p&gt;
&lt;h3 id=&quot;B-Tree索引&quot;&gt;B-Tree索引&lt;/h3&gt;&lt;p&gt;当我们说到索引，如果没有特别指明类型，一般说的就是B-Tree索引，它使用B-Tree数据结构来存储数据。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。&lt;/p&gt;
&lt;p&gt;虽然是使用B-Tree，但是不同的存储引擎可能会使用一些变种的算法，比如InnoDB使用的是B+Tree，即使它的索引名字是BTREE。&lt;/p&gt;
&lt;p&gt;另外，不同的存储引擎，也会以不同的方式使用B-Tree索引，性能也各有不同。比如，InnoDB按原数据格式存储，而MyISAM则使用前缀压缩技术来使得索引更小。再如InnoDB根据&lt;strong&gt;主键&lt;/strong&gt;引用被索引的数据行，而MyISAM通过数据的&lt;strong&gt;物理位置&lt;/strong&gt;引用被索引的数据行。&lt;/p&gt;
&lt;p&gt;B-Tree索引中所有的值都是按顺序存储的，并且每一个叶子节点到根的距离都相同。&lt;/p&gt;
&lt;p&gt;下图是B-Tree索引的抽象表示，大致反映了InnoDB索引是如何工作的。&lt;br&gt;&lt;img src=&quot;http://7xtdiw.com1.z0.glb.clouddn.com/create-high-performance-index-1.png&quot; alt=&quot;建立在B+Tree结构上的索引&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在B树中，以逻辑页的方式组织数据，每个&lt;strong&gt;非叶子页&lt;/strong&gt;包含n个key和n+1个指针（key与指针相互间隔），分别保存着&lt;strong&gt;索引列的值&lt;/strong&gt;和&lt;strong&gt;指向子页的指针&lt;/strong&gt;，这些指针所指向的子页，其内部包含的所有的key值都界于指针左右的两个key值之间。&lt;strong&gt;叶子页&lt;/strong&gt;比较特殊，它包含n个key和1个指针，与非叶子页不同的是，叶子页中的key不仅仅保存索引列的值，&lt;strong&gt;还保存了主键值&lt;/strong&gt;（MyISAM引擎保存的是行的物理位置），用来获取完整的数据行，指针则是&lt;strong&gt;指向下一个叶子页&lt;/strong&gt;（注：这是带有顺序访问指针的B+Tree），这个指针是用来提高范围查询的性能，有了这个指针，当进行范围查询的时候，只要在B树中查到范围区间内的最小值，然后顺着叶子页的指针向后遍历，就可以一次访问到区间内的所有数据，极大的提高了范围查询效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑页是计算机管理存储器的逻辑块，操作系统将内存和磁盘分割为连续的大小相等的块，这里的每个块称为一个逻辑页（在许多操作系统中，页的大小通常为4K，对于InnoDB引擎则为16K），内存和磁盘以页为单位交换数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了B-Tree索引，进行查询的时候就不再需要进行全表扫描，而是从索引的根节点开始向下搜索，通过比较&lt;strong&gt;要查找的值&lt;/strong&gt;和&lt;strong&gt;节点页中的key值&lt;/strong&gt;就可以找到合适的指针进入下层子节点，这些指向子节点的指针实际上定义了子节点内值的上限和下限。最终存储引擎要么找到对应的值，要么记录不存在。&lt;/p&gt;
&lt;p&gt;B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。&lt;/p&gt;
&lt;p&gt;举个更直观的例子，假设有如下表：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE People (&amp;#10;&amp;#9;last_name   varchar(50)    not null,&amp;#10;&amp;#9;first_name  varchar(50)    not null,&amp;#10;&amp;#9;dob         date           not null,&amp;#10;&amp;#9;gender      enum(&amp;#39;m&amp;#39;, &amp;#39;f&amp;#39;) not null,&amp;#10;&amp;#9;key(last_name, first_name, dob)&amp;#10;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在表中，添加了联合索引(last_name, first_name, dob)之后，对于表中的每一行数据，在索引中都保存了索引列的值(last_name, first_name, dob)，该索引的数据存储方式如下图所示：&lt;br&gt;&lt;img src=&quot;http://7xtdiw.com1.z0.glb.clouddn.com/create-high-performance-index-2.png&quot; alt=&quot;B+Tree索引数中的部分条目示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;在图中可以看到，每个页中的值对应的是我们定义的3个索引列的值（last_name, first_name, dob），需要注意的是，索引对多个列进行排序的依据是定义索引时的顺序。（注：在图中，叶子页实际上还保存了主键值，只是在图中没有体现出来）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以使用B-Tree索引的查询类型&lt;/strong&gt;&lt;br&gt;全键值匹配、索引第一列全值匹配、索引第一列前缀匹配、索引第一列范围匹配、前N列全匹配并范围匹配第N+1列、只访问索引的查询（覆盖索引）。&lt;br&gt;简单来说就是一个原则，必须从索引的最左列开始匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于B-Tree索引的限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须按照索引的最左列开始查找。&lt;/li&gt;
&lt;li&gt;不能跳过索引中的列。（某些情况可以使用IN()技巧来绕过这个限制，前提是列值的数量有限）&lt;/li&gt;
&lt;li&gt;如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找。（可以使用多个等于条件来替代范围条件，前提是范围查询列值的数量有限）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里应该可以明白，索引列的顺序是多么的重要，在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。&lt;/p&gt;
&lt;p&gt;注：有些限制并不是B-Tree本身导致的，而是MySQL优化器和存储引擎使用索引的方式导致的，这部分限制有可能在未来的版本中不再是限制。&lt;/p&gt;
&lt;h3 id=&quot;哈希索引&quot;&gt;哈希索引&lt;/h3&gt;&lt;p&gt;哈希索引基于哈希表实现，只有&lt;strong&gt;精确匹配&lt;/strong&gt;索引&lt;strong&gt;所有列&lt;/strong&gt;的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希值，作为键存储在哈希表中，对应的值则是指向每个数据行的指针。如果计算出来的哈希值重复，则以链表的方式存放多个行指针。&lt;/p&gt;
&lt;p&gt;哈希索引的数据结构简化如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   key  |      value     &amp;#10;:------:|:---------------:&amp;#10; 2323   | &amp;#25351;&amp;#21521;&amp;#31532;1&amp;#34892;&amp;#30340;&amp;#25351;&amp;#38024; &amp;#10; 2358   | &amp;#25351;&amp;#21521;&amp;#31532;4&amp;#34892;&amp;#30340;&amp;#25351;&amp;#38024; &amp;#10; 7437   | &amp;#25351;&amp;#21521;&amp;#31532;2&amp;#34892;&amp;#30340;&amp;#25351;&amp;#38024; &amp;#10; 8784   | &amp;#25351;&amp;#21521;&amp;#31532;3&amp;#34892;&amp;#30340;&amp;#25351;&amp;#38024;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上表中的key是根据索引列的值计算得到的哈希值，value则是行指针。需要注意的是，每个key的编号是顺序的，但是数据行不是。&lt;/p&gt;
&lt;p&gt;当MySQL判断一个查询能够使用哈希索引进行查询的时候，会先对索引列使用特定的哈希函数计算得到哈希值，然后再使用该值到哈希表中寻找对应的行指针（有可能多个，使用链表串连），最后比较行指针指向的数据行的值是否与查询的条件一致。&lt;/p&gt;
&lt;p&gt;因为哈希索引只存储&lt;strong&gt;哈希值&lt;/strong&gt;和&lt;strong&gt;行指针&lt;/strong&gt;，所以索引的结构十分紧凑，查找的速度也非常快。&lt;/p&gt;
&lt;p&gt;但是，哈希索引也有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希索引&lt;strong&gt;不存储字段值&lt;/strong&gt;，所以不能使用索引中的值来避免读取行。（不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显）&lt;/li&gt;
&lt;li&gt;因为数据不是按照索引值顺序存储的，所以&lt;strong&gt;无法用于排序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不支持部分索引列的查询，只支持等值比较查询&lt;/strong&gt;。（因为是使用索引列的全部内容来计算哈希值）&lt;/li&gt;
&lt;li&gt;当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行比较，直到找到所有符合条件的行。如果哈希冲突很多，不仅效率会受到影响，而且维护索引的代价也会很高，冲突越多，代价越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，哈希索引只适用于某些特定的场合。&lt;/p&gt;
&lt;h3 id=&quot;空间数据索引&quot;&gt;空间数据索引&lt;/h3&gt;&lt;p&gt;MyISAM引擎支付空间索引，可以用来存储地理数据。空间索引会从所有维度来索引数据，所以不受前缀查询的限制，查询时可以使用任意维度来组合查询。&lt;/p&gt;
&lt;p&gt;MySQL的GIS支持并不完善，索引大部分人不会使用这个特性，开源的关系数据库中对GIS的解决方案做的比较好的是PostgreSQL的PostGIS。&lt;/p&gt;
&lt;h3 id=&quot;全文索引&quot;&gt;全文索引&lt;/h3&gt;&lt;p&gt;全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。不同于其它索引类型，它有许多需要注意的细节，比如停用词、分词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事，而不是简单的WHERE条件匹配。&lt;/p&gt;
&lt;p&gt;目前MySQL对全文索引的支持还不太好，有诸多限制，所以，大多数情况下我们会使用别的解决方案，例如Lucene、ElasticSearch、Solr等。&lt;/p&gt;
&lt;h2 id=&quot;索引是最好的解决方案吗&quot;&gt;索引是最好的解决方案吗&lt;/h2&gt;&lt;p&gt;索引并不总是最好的解决方案。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于非常小的表，大部分情况下，简单的全表扫描更高效。&lt;/li&gt;
&lt;li&gt;对于中到大型的表，索引就非常有效。&lt;/li&gt;
&lt;li&gt;但对于特大型的表，建立和使用索引的代价将随之增长。这种情况，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;高性能的索引策略&quot;&gt;高性能的索引策略&lt;/h2&gt;&lt;p&gt;正确的创建和使用索引，是实现高性能查询的基础。&lt;/p&gt;
&lt;h3 id=&quot;独立的列&quot;&gt;独立的列&lt;/h3&gt;&lt;p&gt;“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数，如果查询中的列不是独立的，那么MySQL就不会使用索引。&lt;/p&gt;
&lt;p&gt;下面是一些常见的错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select … where id + 1 = 5&lt;/li&gt;
&lt;li&gt;select … where current_date - date_col &amp;lt; 10&lt;/li&gt;
&lt;li&gt;select … where date_format(date_col, ‘%Y-%m-%d’) = date_format(current_date, ‘%Y-%m-%d’)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。&lt;/p&gt;
&lt;h3 id=&quot;前缀索引和索引选择性&quot;&gt;前缀索引和索引选择性&lt;/h3&gt;&lt;p&gt;前缀索引：在建立索引的时候，只索引列的开始部分字符，而不是索引完整列。&lt;br&gt;索引选择性：对于要索引的列，不重复的行数(也称为基数)与表的总记录数的比值，索引选择性越高，则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。&lt;/p&gt;
&lt;p&gt;当索引很长的字符串的时候，索引会变得大而且慢。这时候通常可以使用前缀索引，这样可以节约索引空间，从而提高索引效率。虽然这样会降低索引的选择性，不过一般情况下，列的前缀的选择性也是足够高的，足以满足查询性能。&lt;/p&gt;
&lt;p&gt;创建前缀索引的关键在于选择合适的前缀长度，从而保证较高的选择性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算合适的前缀长度&lt;/strong&gt;，有两种常用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计最常见的值的数量，然后再统计最常见的前缀的数量，让二者的数量接近。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#20808;&amp;#32479;&amp;#35745;&amp;#26368;&amp;#24120;&amp;#35265;&amp;#20540;&amp;#30340;&amp;#25968;&amp;#37327;&amp;#65306;&amp;#10;&amp;#9;select col, count(*) as cnt &amp;#10;&amp;#9;from table group by col order by cnt desc limit 10;&amp;#10;&amp;#20877;&amp;#32479;&amp;#35745;&amp;#26368;&amp;#24120;&amp;#35265;&amp;#30340;&amp;#21069;&amp;#32512;&amp;#30340;&amp;#25968;&amp;#37327;&amp;#65292;&amp;#21069;&amp;#32512;&amp;#38271;&amp;#24230;&amp;#20026;length&amp;#10;&amp;#9;select left(col, length) as pref, count(*) as cnt &amp;#10;&amp;#9;from table group by pref order by cnt desc limit 10;&amp;#10;&amp;#28982;&amp;#21518;&amp;#22686;&amp;#21152;&amp;#21069;&amp;#32512;&amp;#38271;&amp;#24230;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#20197;&amp;#19978;&amp;#20004;&amp;#26465;SQL&amp;#32479;&amp;#35745;&amp;#20986;&amp;#26469;&amp;#30340;&amp;#32467;&amp;#26524;&amp;#25509;&amp;#36817;&amp;#65292;&amp;#25509;&amp;#36817;&amp;#21518;&amp;#30340;length&amp;#21363;&amp;#20026;&amp;#21512;&amp;#36866;&amp;#30340;&amp;#21069;&amp;#32512;&amp;#38271;&amp;#24230;&amp;#12290;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;计算完整列的选择性和前缀的选择性，让二者接近。&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#20808;&amp;#35745;&amp;#31639;&amp;#23436;&amp;#25972;&amp;#21015;&amp;#30340;&amp;#36873;&amp;#25321;&amp;#24615;&amp;#65306;&amp;#10;&amp;#9;select count(distinct col)/count(*) from table;&amp;#10;&amp;#20877;&amp;#35745;&amp;#31639;&amp;#19981;&amp;#21516;&amp;#21069;&amp;#32512;&amp;#38271;&amp;#24230;&amp;#30340;&amp;#36873;&amp;#25321;&amp;#24615;&amp;#65306;&amp;#10;&amp;#9;select count(distinct left(col, 3))/count(*) as sel3,&amp;#10;&amp;#9;&amp;#9;count(distinct left(col, 4))/count(*) as sel4,&amp;#10;&amp;#9;&amp;#9;count(distinct left(col, 5))/count(*) as sel5,&amp;#10;&amp;#9;&amp;#9;count(distinct left(col, 6))/count(*) as sel6,&amp;#10;&amp;#9;&amp;#9;count(distinct left(col, 7))/count(*) as sel7 &amp;#10;&amp;#9;from table;&amp;#10;&amp;#26368;&amp;#21518;&amp;#36873;&amp;#25321;&amp;#19968;&amp;#20010;&amp;#36873;&amp;#25321;&amp;#24615;&amp;#25509;&amp;#36817;&amp;#30340;&amp;#21069;&amp;#32512;&amp;#38271;&amp;#24230;&amp;#21363;&amp;#21487;&amp;#12290;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找到了合适的前缀长度后，就可以通过下面的SQL来&lt;strong&gt;创建前缀索引&lt;/strong&gt;了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- &amp;#22312;col&amp;#21015;&amp;#19978;&amp;#21019;&amp;#24314;&amp;#38271;&amp;#24230;&amp;#20026;7&amp;#30340;&amp;#21069;&amp;#32512;&amp;#32034;&amp;#24341;&amp;#10;alter table table_name add key(col(7));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另一方面，前缀索引也有其&lt;strong&gt;缺陷&lt;/strong&gt;：无法使用前缀索引做order by和group by，也无法做覆盖索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用前缀索引的常见场景&lt;/strong&gt;：针对很长的十六进制唯一ID使用前缀索引。比如使用MySQL来存储网站的sessionid的时候，需要在一个很长的十六进制字符串上创建索引，这时候如果采用长度为8的前缀索引通常能显著的提升性能。&lt;/p&gt;
&lt;p&gt;注：MySQL不支持后缀索引，但是可以把字符反转后存储，并基于此建立前缀索引。&lt;/p&gt;
&lt;h3 id=&quot;多列索引&quot;&gt;多列索引&lt;/h3&gt;&lt;p&gt;多列索引包括：多个单列索引和联合索引。&lt;/p&gt;
&lt;p&gt;很多人对多列索引的理解不够，常见的错误是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。&lt;/p&gt;
&lt;p&gt;实际上，创建多个单列索引大部分情况下并不能提高查询性能。MySQL5.0以后的版本引入了一种叫“索引合并“策略，一定程度上可以使用表上的多个单列索引来定位指定的行，但是之前的版本只能使用其中某一个单列索引，这种情况下没有哪一个单列索引是非常有效的。&lt;/p&gt;
&lt;p&gt;对于下面的SQL：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select id1, id2 from table where id1 = 1 or id2 = 1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在老的MySQL版本中，不论创建什么索引，对这个查询都会使用全表扫描。&lt;br&gt;除非将OR条件改为UNION ALL的方式，然后分别对id1和id2建立单列索引：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select id1, id2 from table where id1 = 1&amp;#10;union all&amp;#10;select id1, id2 from table where id2 = 1 and id1 &amp;#60;&amp;#62; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是在MySQL5.0以后的版本，查询能够同时使用这两个单列索引进行查询，然后将结果合并。&lt;/p&gt;
&lt;p&gt;虽然有了新的版本有了索引合并策略，但这是一种优化的结果，实际上更多时候，这也说明了表上的索引建得很糟糕。下面是一些经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对多个索引使用AND条件时，需要一个包含所有相关列的联合索引，而不是多个单列索引。&lt;/li&gt;
&lt;li&gt;对多个索引使用OR条件时，通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上，还可能会影响查询的并发性。但如果是单独运行这样的查询，则可以忽略对并发性的影响。通常来说，还不如将查询改写成UNION的方式更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;选择合适的索引列顺序&quot;&gt;选择合适的索引列顺序&lt;/h3&gt;&lt;p&gt;如何选择合适的索引列顺序，可以说是最容易引起困惑的问题了。&lt;/p&gt;
&lt;p&gt;有一个经验法则：&lt;strong&gt;将选择性最高的列放到索引最前列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个经验在不需要考虑排序和分组时很有用，因为这时候索引的作用只是用来优化where条件的查询。但是在需要考虑排序和分组时，&lt;strong&gt;避免随机IO和排序&lt;/strong&gt;则更重要。&lt;/p&gt;
&lt;p&gt;另外，性能不只是依赖于索引列的选择性，也和查询条件的具体值有关，可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。&lt;/p&gt;
&lt;p&gt;以下面的查询为例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from payment where staff_id = 2 and customer_id = 584;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是应该创建一个(staff_id, customer_id)索引还是应该颠倒一下顺序呢？可以分别计算列的选择性，然后将选择性高的作为索引列的第一列。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select count(distinct staff_id)/count(*) as staff_selectivity,&amp;#10;  count(distinct customer_id)/count(*) as customer_selectivity&amp;#10;from payment \G&amp;#10;************************* 1.row ************************&amp;#9;&amp;#10;&amp;#9;&amp;#9;staff_selectivity : 0.0001&amp;#10;&amp;#9;customer_selectivity  : 0.0373&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;customer_id的选择性更高，所以将其作为索引的第一列。&lt;/p&gt;
&lt;p&gt;需要注意的是，上面的方式在多数情况是有用的，但是不要假设平均情况下的性能能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能。所以，特殊情况，需要特殊考虑。&lt;/p&gt;
&lt;h3 id=&quot;聚簇索引&quot;&gt;聚簇索引&lt;/h3&gt;&lt;p&gt;聚簇索引并不是一种索引类型，而是一种&lt;strong&gt;数据存储方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。&lt;/p&gt;
&lt;p&gt;当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，因为无法将数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。&lt;/p&gt;
&lt;p&gt;聚簇索引中的记录存放方式，如下图所示：&lt;br&gt;&lt;img src=&quot;http://7xtdiw.com1.z0.glb.clouddn.com/create-high-performance-index-3.png&quot; alt=&quot;聚簇索引的数据分布&quot;&gt;&lt;br&gt;需要注意的是，叶子页保存了行的全部数据，节点页只保存了主键值。&lt;/p&gt;
&lt;p&gt;MySQL无法选择哪个索引作为聚簇索引，对于InnoDB，默认使用主键作为聚簇索引，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，则隐式定义一个主键来作为聚簇索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚簇索引的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以把相关数据保存在一起，获取相关数据时可以减少从磁盘读取数据页，从而减少磁盘IO。&lt;/li&gt;
&lt;li&gt;由于将索引和数据保存在同一个B-Tree种，因此获取数据通常比在非聚簇索引中查找要快。&lt;/li&gt;
&lt;li&gt;使用覆盖索引的查询可以直接使用页节点中的主键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;聚簇索引的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入速度严重依赖于插入顺序。在InnoDB中按照主键的顺序插入是最快的方式。如果不是按照主键顺序插入，那么在完成后最好使用OPTIMIZE TABLE命令重新组织一下表。&lt;/li&gt;
&lt;li&gt;更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。&lt;/li&gt;
&lt;li&gt;插入新行或者主键被更新导致需要移动行的时候，可能面临“页分裂”问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，会导致表占用更多的磁盘空间。&lt;/li&gt;
&lt;li&gt;可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候，因为需要访问更多的页，意味着需要更多的磁盘IO。&lt;/li&gt;
&lt;li&gt;二级索引访问需要两次索引查找，而不是一次。（因为二级索引叶子页中保存的是行的主键值，这意味着存储引擎在获得主键值后，还需要根据主键值去聚簇索引中查找对应的数据行，这就做了重复的工作：两次B-Tree查找。对应InnoDB，自适应哈希索引能够减少这样的重复工作）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;*覆盖索引&quot;&gt;*覆盖索引&lt;/h3&gt;&lt;p&gt;覆盖索引的定义：如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就成为覆盖索引。&lt;br&gt;MySQL可以使用覆盖索引来直接获取列的数据，这样就不再需要回表查询来读取数据行，能够极大地提高性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;覆盖索引带来的好处&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于索引的列通常远小于数据行的大小，所以覆盖索引极大地减少了数据访问量。&lt;/li&gt;
&lt;li&gt;由于InnoDB的二级索引在叶子节点中只保存了行的主键值，所以如果二级索引能够覆盖查询，则可以避免对主键索引的二次查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于覆盖索引必须要存储索引列的值，而除了B-Tree索引以外的其它索引类型都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。&lt;/p&gt;
&lt;p&gt;下面是一个SQL查询：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select id, col from table;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果我们在表中创建一个多列索引(id, col)，那么上面的查询就可以称为索引覆盖查询，因为要查询的列在索引中都可以直接获取到。&lt;/p&gt;
&lt;p&gt;下面举个例子来说明，如何使用覆盖索引来优化SQL语句。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from products where actor = &amp;#39;sean carrey&amp;#39; and title like &amp;#39;%pollo%&amp;#39;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于上面的SQL，创建多列索引(actor, title)，即使这样，索引也无法覆盖该查询，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询从表中选择了所有列。&lt;/li&gt;
&lt;li&gt;不能在索引中使用以通配符开头的like查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有办法可以解决上面说的两个问题，只需要重写并巧妙的设计索引。&lt;br&gt;先将索引扩展至覆盖三个数据列(actor, title, prod_id)，然后重写查询：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from products&amp;#10;join (&amp;#10;&amp;#9;select prod_id from products where actor = &amp;#39;Sean Carrey&amp;#39; and title like &amp;#39;%Apollo%&amp;#39;&amp;#10;) as t1 &amp;#10;on (t1.prod_id = products.prod_id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面重写后的查询，在子查询中就可以使用覆盖索引，找到匹配的prod_id，再根据prod_id在外层查询匹配获取需要的所有列值。这种方式叫做&lt;strong&gt;延迟关联&lt;/strong&gt;，因为延迟了对列的访问。&lt;br&gt;这样优化能提升效率的原因在于：巧妙的运用了覆盖索引，从而减少了需要读取的完整数据行。&lt;br&gt;这样&lt;strong&gt;优化的效果取决于where条件匹配返回的行数&lt;/strong&gt;。&lt;br&gt;假设这个products表有100万行记录，我们来看一下上面两个查询在三个不同的数据集上的表现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个数据集：Sean Carrey出演了 &lt;strong&gt;30000&lt;/strong&gt; 部作品，其中有 &lt;strong&gt;20000&lt;/strong&gt; 部的标题中包含了Apollo。&lt;/li&gt;
&lt;li&gt;第二个数据集：Sean Carrey出演了 &lt;strong&gt;30000&lt;/strong&gt; 部作品，其中有 &lt;strong&gt;40&lt;/strong&gt; 部的标题中包含了Apollo。&lt;/li&gt;
&lt;li&gt;第三个数据集：Sean Carrey出演了 &lt;strong&gt;50&lt;/strong&gt; 部作品，其中有 &lt;strong&gt;10&lt;/strong&gt; 部的标题中包含了Apollo。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用上面三种数据集来测试两种不同的查询，结果如下：&lt;br&gt;&lt;img src=&quot;http://7xtdiw.com2.z0.glb.clouddn.com/create-high-performance-index-4.png&quot; alt=&quot;测试结果&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例1中，查询返回了一个很大的结果集，因此看不到优化后的效果。因为大部分时间都花在读取和发送数据上了。&lt;/li&gt;
&lt;li&gt;示例2中，经过覆盖索引的过滤，只返回了很少的结果集，优化的效果非常明显，主要得益于只需要读取40行完整数据行，而不是原来需要的30000行。&lt;/li&gt;
&lt;li&gt;示例3中，效率反而下降，因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也是优化大分页的一种方法：使用延迟关联，并使用覆盖索引查询需要的主键，再根据主键关联原表来获得需要的行。这可以大大减少MySQL需要扫描的行数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select &amp;#60;cols&amp;#62; from table inner join( &amp;#10;&amp;#9;select &amp;#60;primary key cols&amp;#62; from table limit 100000, 10&amp;#10;) as t using(&amp;#60;primary key cols&amp;#62;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，可以进一步优化InnoDB，因为InnoDB的二级索引的叶子节点包含了主键的值，所以可以有效地利用这些主键列来覆盖查询。&lt;/p&gt;
&lt;h3 id=&quot;*使用索引扫描来做排序&quot;&gt;*使用索引扫描来做排序&lt;/h3&gt;&lt;p&gt;MySQL有两种方式可以生成有序的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过排序操作&lt;/li&gt;
&lt;li&gt;按索引顺序扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扫描索引本身是很快的，但是，如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行，这基本上都是随机IO，因此按索引顺序读取数据的速度通过要比顺序地全表扫描慢。&lt;/p&gt;
&lt;p&gt;MySQL可以使用同一个索引既满足排序，又用于查找行，设计索引时应尽可能地同时满足这两种任务，这样最好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能使用索引做排序的条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引列的顺序和order by子句的顺序完全一致，并且所有列的排序方向都一样（要么全是升序，要么全是降序）。&lt;/li&gt;
&lt;li&gt;多表查询时，order by子句引用的字段全部为第一个表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order by子句和查找型查询的限制一样，都需要满足索引的最左前缀的要求。&lt;/li&gt;
&lt;li&gt;有一种情况情况可以不满足最左前缀要求：where和order by中的列可以组合成最左前缀，并且where子句中都是使用常量查询（等值查询）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，是一些基本原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能将需要做范围查询的列放到索引的最后面&lt;/li&gt;
&lt;li&gt;可以通过In()的方式覆盖那些不在where子句中的列&lt;/li&gt;
&lt;li&gt;避免多个范围条件，可以的话，使用多个等值条件带范围条件。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;索引是存储引擎用于&lt;strong&gt;高效获取数据&lt;/strong&gt;的一种&lt;strong&gt;数据结构&lt;/strong&gt;，索引其实就是一种数据结构。索引对于良好的性能非常关键，索引优化是对查询性能优化最有效的手段。&lt;/p&gt;
&lt;h2 id=&quot;索引基础&quot;&gt;索引基础&lt;/h2&gt;&lt;p&gt;要理解
    
    </summary>
    
      <category term="MySQL" scheme="http://qq2867234.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://qq2867234.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="http://qq2867234.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS防御</title>
    <link href="http://qq2867234.github.io/2015/11/09/XSS-defence/"/>
    <id>http://qq2867234.github.io/2015/11/09/XSS-defence/</id>
    <published>2015-11-09T15:24:48.000Z</published>
    <updated>2016-04-25T13:49:43.237Z</updated>
    
    <content type="html">&lt;h2 id=&quot;XSS的定义&quot;&gt;XSS的定义&lt;/h2&gt;&lt;p&gt;XSS 全称Cross Site Script，跨站脚本攻击，HTML注入。&lt;/p&gt;
&lt;p&gt;通过前端代码注入篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。&lt;/p&gt;
&lt;p&gt;带来cookie劫持问题、窃取用户信息、模拟用户身份执行操作等。&lt;/p&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;&lt;h4 id=&quot;HttpOnly（有助于缓解XSS攻击）&quot;&gt;HttpOnly（有助于缓解XSS攻击）&lt;/h4&gt;&lt;p&gt;浏览器禁止页面的脚本访问带有HttpOnly属性的Cookie（严格来讲它解决的是Cookie劫持攻击）&lt;/p&gt;
&lt;p&gt;一旦窃取用户的Cookie，就可以登录它的账户，但如果为Cookie设置了HttpOnly，这种攻击就会失败。&lt;/p&gt;
&lt;p&gt;在所有set-cookie的地方，给关键cookie都加上HttpOnly。&lt;/p&gt;
&lt;p&gt;HttpOnly并不是万能的，添加了不等于解决了XSS问题，它有助于缓解XSS攻击，但仍然需要其他能够解决XSS漏洞的方案。&lt;/p&gt;
&lt;h4 id=&quot;输入检查（没有结合语境，不够智能）&quot;&gt;输入检查（没有结合语境，不够智能）&lt;/h4&gt;&lt;p&gt;输入检查，很多时候被用于格式检查，必须放在服务器端代码中实现。&lt;/p&gt;
&lt;p&gt;在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如 &lt;code&gt;&amp;lt; &amp;gt; &amp;#39; &amp;quot;&lt;/code&gt; 等，如果发现则过滤或编码。&lt;/p&gt;
&lt;p&gt;比较智能的输入检查可能还会匹配XSS特征，称为“XSS Filter”&lt;/p&gt;
&lt;p&gt;全局的XSS Filter无法看到用户数据的输出语境，可能会漏报或者改变用户数据的语义，比如&lt;code&gt;1+1 &amp;gt; 2&lt;/code&gt; ，如果XSS Filter不够智能的话，就会粗暴的把 &amp;gt; 给过滤了。&lt;/p&gt;
&lt;p&gt;输入数据，还可能被展示在多个地方呢，每个地方的语境可能各不相同，如果使用单一的替换操作，则可能会出现问题。&lt;/p&gt;
&lt;h4 id=&quot;输出检查&quot;&gt;输出检查&lt;/h4&gt;&lt;p&gt;除了富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。&lt;/p&gt;
&lt;p&gt;为了对抗XSS，在HtmlEncode中要求至少转换以下字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp; -&amp;gt; &lt;span class=&quot;code&quot;&gt;`&amp;amp;amp;`&lt;/span&gt;  
&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt; &lt;span class=&quot;attribute&quot;&gt;-&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;code&quot;&gt;`&amp;amp;lt;`&lt;/span&gt;  
&lt;span class=&quot;blockquote&quot;&gt;&amp;gt; -&amp;gt; `&amp;amp;gt;`  &lt;/span&gt;
&quot; -&amp;gt; &lt;span class=&quot;code&quot;&gt;`&amp;amp;quot;`&lt;/span&gt;  
&#39; -&amp;gt; &lt;span class=&quot;code&quot;&gt;`&amp;amp;#x27;`&lt;/span&gt;  
/ -&amp;gt; &lt;span class=&quot;code&quot;&gt;`&amp;amp;#x2F;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript的编码方式可以使用JavascriptEncode，并且在对抗XSS时，还要求输出的变量必须在括号内部，以避免造成安全问题。&lt;/p&gt;
&lt;p&gt;比较下面两种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x = escapeJavascript(&lt;span class=&quot;variable&quot;&gt;$evil&lt;/span&gt;);
var y = &lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;+escapeJavascript(&lt;span class=&quot;variable&quot;&gt;$evil&lt;/span&gt;)+&lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的两行代码可能会变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;alert(&#39;xxs&#39;);
&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; y&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;1;alert(&#39;xxs&#39;);&quot;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前者执行了而外的代码，后者则是安全的。&lt;br&gt;在“Apache Common Lang”的“StringEscapeUtils”里，提供了许多的escape函数。&lt;br&gt;需要注意的是，编码后的长度可能会发生改变，从而影响某些有字符长度限制的功能。&lt;/p&gt;
&lt;h2 id=&quot;正确地防御XSS&quot;&gt;正确地防御XSS&lt;/h2&gt;&lt;p&gt;XSS的本质还是一种“HTML注入”，用户的数据被当成了HTML代码的一部分来执行。&lt;/p&gt;
&lt;p&gt;使用MVC架构的网站，XSS发生在View层，在应用拼接变量到HTML页面时产生。所以在用户提交数据处进行输入检查的方案，其实并不是在真正发生攻击的地方做防御。&lt;/p&gt;
&lt;p&gt;要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。&lt;/p&gt;
&lt;h4 id=&quot;在HTML标签中输出&quot;&gt;在HTML标签中输出&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;span class=&quot;variable&quot;&gt;$var&lt;/span&gt;&amp;lt;/div&amp;gt;
&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt; &amp;gt;&lt;span class=&quot;variable&quot;&gt;$var&lt;/span&gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;攻击方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;alert(&lt;span class=&quot;regexp&quot;&gt;/xss/&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;#&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;onerror&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;alert(1)&lt;/span&gt; /&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;防御方法： 对变量使用HtmlEncode。&lt;/p&gt;
&lt;h4 id=&quot;在HTML属性中输出&quot;&gt;在HTML属性中输出&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;property&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt; &lt;span class=&quot;property&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$var&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span class=&quot;keyword&quot;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;攻击方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;abc&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;alert(&lt;span class=&quot;regexp&quot;&gt;/xss/&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;防御方法： 对变量使用HtmlEncode。&lt;/p&gt;
&lt;p&gt;在OWASP ESAPI中推荐了一种更严格的HtmlEncode：除了字母、数字外，其它所有的特殊字符都被编码成HTMLEntities。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String sage = ESAPI.encoder&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;.encodeForHTMLAttribute&lt;span class=&quot;params&quot;&gt;(request.getParameter&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;input&quot;&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种严格的编码方式，可以保证不会出现任何安全问题。&lt;/p&gt;
&lt;h4 id=&quot;在_script_标签中输出&quot;&gt;在 script 标签中输出&lt;/h4&gt;&lt;p&gt;首先应该确保输出的变量在引号中：&lt;code&gt;&amp;lt;script&amp;gt;var x = &amp;quot;$var&amp;quot;;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br&gt;攻击者需要先闭合引号才能实施XSS攻击。&lt;br&gt;防御方法： 使用JavascriptEncode。&lt;/p&gt;
&lt;h4 id=&quot;在事件中输出&quot;&gt;在事件中输出&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;func(&#39;$var&#39;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;攻击方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;func(&#39;&#39;);alert(/xss/);//&#39;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;防御方法： 使用JavascriptEncode。&lt;/p&gt;
&lt;h4 id=&quot;在地址中输出&quot;&gt;在地址中输出&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;[&lt;span class=&quot;link_label&quot;&gt;Protocal&lt;/span&gt;][&lt;span class=&quot;link_reference&quot;&gt;Host&lt;/span&gt;][&lt;span class=&quot;link_label&quot;&gt;Path&lt;/span&gt;][&lt;span class=&quot;link_reference&quot;&gt;Search&lt;/span&gt;][&lt;span class=&quot;link_label&quot;&gt;Hash&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在URL的path或者search中输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;http://www.evil.com/?test=$var&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;攻击方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&lt;span class=&quot;tag&quot;&gt;a&lt;/span&gt; href=&lt;span class=&quot;string&quot;&gt;&quot;http://www.evil.com/?test=&quot;&lt;/span&gt; onclick=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;test&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;防御方法： 使用URLEncode。&lt;/p&gt;
&lt;p&gt;整个URL能够被用户完全控制&lt;br&gt;此时不能使用URLEncode，否则会改变URL的语义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;$var&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;攻击方式：构造伪协议实施攻击&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;javascript:alert(1);&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;防御方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先检查变量是否以http开头，如果不是则自动添加，以保证不会出现伪协议类的XSS攻击&lt;/li&gt;
&lt;li&gt;再对变量进行URLEncode，即可保证不会有此类的XSS发生了。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS的定义&quot;&gt;XSS的定义&lt;/h2&gt;&lt;p&gt;XSS 全称Cross Site Script，跨站脚本攻击，HTML注入。&lt;/p&gt;
&lt;p&gt;通过前端代码注入篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。&lt;/p&gt;
&lt;p&gt;带来cookie劫持问题、窃取用户
    
    </summary>
    
      <category term="Web" scheme="http://qq2867234.github.io/categories/Web/"/>
    
    
      <category term="Web安全" scheme="http://qq2867234.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
